(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{475:function(t,e,_){"use strict";_.r(e);var v=_(28),n=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_01-什么是ai-agent-智能体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_01-什么是ai-agent-智能体"}},[t._v("#")]),t._v(" 01-什么是AI Agent（智能体）")]),t._v(" "),_("p",[t._v("Agent的核心思想是使用预压模型来选择要采取的一系列操作。在Agent中，语言模型被用作推理引擎来确认要采用哪些操作以及按照什么顺序。相对比传统机械或软件被动的给予输入->做出输出的模式，Agent由于更加强调自主的发现问题、确定目标、构想方案、选择方案、执行方案、检查更新的特性，因此可以被认为是一类拥有自主智能的实体,而被广泛称为智能体。")]),t._v(" "),_("p",[_("strong",[t._v("非智能体、智能体以及人类创作者的工作流呈现显著差异：")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("主体类型")]),t._v(" "),_("th",[t._v("执行特征")]),t._v(" "),_("th",[t._v("流程剖析")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("Non-Agent（非智能体）")]),t._v(" "),_("td",[t._v("线性单次输出")]),t._v(" "),_("td",[t._v("用户输入提示词→大模型直接生成终稿（无迭代过程）")])]),t._v(" "),_("tr",[_("td",[t._v("AI Agent（智能体")]),t._v(" "),_("td",[t._v("多阶段认知闭环")]),t._v(" "),_("td",[t._v("规划大纲→检索资料→生成初稿→自检修订→循环优化→输出终稿（模拟人类创作思维）")])]),t._v(" "),_("tr",[_("td",[t._v("人类创作者")]),t._v(" "),_("td",[t._v("认知驱动型工作流")]),t._v(" "),_("td")])])]),t._v(" "),_("p",[t._v("AI Agent的核心是通过任务解构-执行-反思的认知闭环，实现对人类工作范式的数字孪生")]),t._v(" "),_("p",[t._v("AI行业大牛吴恩达认为：AI Agent的终极演变方向是构建具备完整认知能力的数字主题。技术架构可以分为四个核心")]),t._v(" "),_("ul",[_("li",[t._v("反思：AI Agent 模拟人类自我修正行为，如:学生完成作业后的自我检查过程。突破单次推理局限，建立错误检测-反馈-修正的增强回路")]),t._v(" "),_("li",[t._v("工具调用： AI Agent判断自身边界能力，选择合适的AI 工具来提供大模型的能力边界")]),t._v(" "),_("li",[t._v("规划：AI Agent在解决复杂问题时，为达到目标制定合理的行为计划能力，从而对任务进行分解。")]),t._v(" "),_("li",[t._v("多智能体协同：多个AI Agent的组合应用，")])]),t._v(" "),_("h2",{attrs:{id:"_02-ai-agent的主流设计模式有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_02-ai-agent的主流设计模式有哪些"}},[t._v("#")]),t._v(" 02-AI Agent的主流设计模式有哪些")]),t._v(" "),_("p",[t._v("当前主流的AI Agent都是基于LLM大模型 + 一整套AIGC算法解决方案(Prompts工程、Function Call、MCP、AI工程策略、AI功能服务等)构建而成，同事蔚来还会持续扩展其内涵。")]),t._v(" "),_("p",[t._v("基于上面额框架，接着再形成了5种主流的AI Agent设计模式:")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("反射模式")]),t._v("：这个模式的核心运作机制是构建自检-纠错迭代环，AI Agent会审查其工作及发现错误并迭代，直到生成最终输出结果。")]),t._v(" "),_("li",[_("strong",[t._v("工具使用模式")]),t._v("：AI Agent允许LLM大模型通过使用外部工具获得更多信息，包括调用API，使用AI服务，查询矢量数据库、执行Python脚本等。这使得LLM大模型不仅仅依赖于其内部知识，还可以获得互联网世界的庞大实时数据流来扩展知识边界。")]),t._v(" "),_("li",[_("strong",[t._v("ReAct模式")]),t._v(": ReAct模式结合了反射模式与工具使用模式，这使其成为当前AI Agent使用的最强大的模式之一。 AI Agent既可以自我思考，自我纠错，还可以使用工具与世界交互。")]),t._v(" "),_("li",[_("strong",[t._v("规划模式")]),t._v("：在这种模式下，AI Agent根据任务的复杂程度,设计任务计划流程，对任务进行细分，再对细分子任务动用ReAct模式进行处理")]),t._v(" "),_("li",[_("strong",[t._v("多智能体模式")]),t._v("：在这个模式下，AI Agent系统中包括多个子Agent，每个子Agent都分配有一个专用的角色和任务，同时每个子Agent还可以访问外部工具进行综合工作。最后，所有子Agent协同工作以提供最终结果，同时根据需要将细分任务委派给其他子Agent，形成一个复杂的”AI Agent协同社区“。")])]),t._v(" "),_("h2",{attrs:{id:"_03-什么是ai-agent中的function-call"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_03-什么是ai-agent中的function-call"}},[t._v("#")]),t._v(" 03-什么是AI Agent中的function call？")]),t._v(" "),_("p",[t._v("在AI Agent中，Function Call(函数调用)本质上是智能体通过LLM大模型调用外部能力(API、AI服务、AI工具、数据库、搜索引擎等)并进行整合处理的闭环处理。")]),t._v(" "),_("p",[t._v("买一个红色毛衣\n流程：需求解析-> 工具决策->结果整合")]),t._v(" "),_("p",[_("strong",[t._v("Function Call 与传统API调用的本质区别")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("维度")]),t._v(" "),_("th",[t._v("传统API调用")]),t._v(" "),_("th",[t._v("Agent Function Call")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("输入格式")]),t._v(" "),_("td",[t._v("结构化参数")]),t._v(" "),_("td",[t._v("自然语言指令")])]),t._v(" "),_("tr",[_("td",[t._v("调用方")]),t._v(" "),_("td",[t._v("开发者硬编码触发")]),t._v(" "),_("td",[t._v("Agent自主决策触发")])]),t._v(" "),_("tr",[_("td",[t._v("错误处理")]),t._v(" "),_("td",[t._v("显示异常捕获")]),t._v(" "),_("td",[t._v("反射机制自动重试、替换工具")])]),t._v(" "),_("tr",[_("td",[t._v("协议依赖")]),t._v(" "),_("td",[t._v("固定通信协议(REST、gRPC)")]),t._v(" "),_("td",[t._v("支持MCP等自适应协议")])])])]),t._v(" "),_("h2",{attrs:{id:"_04-什么是ai-agent中的mcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_04-什么是ai-agent中的mcp"}},[t._v("#")]),t._v(" 04-什么是AI Agent中的MCP")]),t._v(" "),_("p",[t._v("MCP全称：Model Context Protocal，构建了AI大模型与外部应用程序间的上下文交互规范，这使得AI开发者能够以一致的规范将各种实时数据源、AI工具与外接功能连接到AIGC大模型中。")]),t._v(" "),_("p",[t._v("MCP由三个核心组件构成：Host、Client和Server、")]),t._v(" "),_("p",[t._v("Host:AI Agent作为Host，负责接受我们的提问与其中的AIGC大模型交互。Client：当AIGC大模型需要确定毛衣购买方案时，Host内置的MCP Client会被激活。这个Client负责与适当的MCP Server建立连接。Server：在这个例子中，毛衣购买方案MCP Server会被调用。它负责执行实际的毛衣购买方案确定操作，访问对应的电商API，并返回找到的毛衣购买方案。")]),t._v(" "),_("p",[t._v("整个流程：我们的问题->AI Agent(Client) ->AIGC模型 -> 需要购买的毛衣信息 -> MCP Client 连接 -> 毛衣购买MCP Server -> 执行操作 -> 返回结果 -> AIGC大模型生成回答 -> 显示在AI Agent上")]),t._v(" "),_("h2",{attrs:{id:"_05-ai-agent中function-call-和mcp中的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_05-ai-agent中function-call-和mcp中的区别是什么"}},[t._v("#")]),t._v(" 05-AI Agent中function call 和MCP中的区别是什么？")]),t._v(" "),_("p",[t._v("在AI Agent领域，MCP可以说是function call的更进一步延伸和封装")]),t._v(" "),_("p",[t._v("function call解决了AIGC大模型与外部应用工具交互的问题，而MCP在此基础上对交互的整个流程进行规范化，从而解决海量数据、AIGC大模型、AI应用工具之间的“孤岛问题”")]),t._v(" "),_("h2",{attrs:{id:"_06-ai-agent中的agent2agent-a2a"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_06-ai-agent中的agent2agent-a2a"}},[t._v("#")]),t._v(" 06-AI Agent中的Agent2Agent(A2A)")]),t._v(" "),_("p",[t._v('Agent2Agent(A2A)协议是驱动多智能体生态系统的核心通信框架，其本质是AI Agent之间的标准化协议，也是Agent之间的"社会契约"')]),t._v(" "),_("p",[t._v("在没有A2A协议之前，不同的Agent A (ds) 与Agent B(GPT-4o) 输出格式各异，无法进行协同合作，形成了很多的AI Agent孤岛")]),t._v(" "),_("p",[t._v("因此通过A2A协议，为异构AI Agent之间的互通与交互提供通用的语言：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/aiAgent/1.png",alt:""}})]),t._v(" "),_("h2",{attrs:{id:"_07-ai-agent中的a2a和mcp的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_07-ai-agent中的a2a和mcp的区别是什么"}},[t._v("#")]),t._v(" 07-AI Agent中的A2A和MCP的区别是什么？")]),t._v(" "),_("p",[t._v("MCP协议解决的是AI Agent和各种外部工具/资源之间的交互问题，可以看做是一个AI应用商店协议，主要关注单个AI Agent如何更好的使用外部工具。")]),t._v(" "),_("p",[t._v("而A2A协议解决的是AI Agent 和AI Agent之间的交互问题，主要关注不同的AI Agent之间怎么协作的问题\n总的来说，他们是互补的，共同构建AI Agent的生态")]),t._v(" "),_("h2",{attrs:{id:"_08-ai-agent系统提示词有哪些作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_08-ai-agent系统提示词有哪些作用"}},[t._v("#")]),t._v(" 08-AI Agent系统提示词有哪些作用")]),t._v(" "),_("p",[t._v("系统提示词(sys prompt)是 AI Agent的核心控制中枢")]),t._v(" "),_("ul",[_("li",[t._v("作用一：角色定义与人格建模")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 法律顾问Agent示例\n"""\n身份：环球律所高级合伙人（执业15年）\n专长领域：跨境并购、知识产权诉讼\n语言风格：严谨专业，引用法条需标注出处\n"""\n\n')])])]),_("ul",[_("li",[t._v("作用二: 能力边界锁定")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 工具调用白名单\n"""\n可用工具：\n  - contract_review：合同审查（输入PDF→输出风险报告）\n  - clause_search：条款库检索（关键词→相似判例）\n禁用行为：\n  - 生成法律效力承诺\n  - 解释未生效草案\n"""\n')])])]),_("ul",[_("li",[t._v("作用三：认识框架植入")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("任务类型")]),t._v(" "),_("th",[t._v("预设思维链")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("合同审查")]),t._v(" "),_("td",[t._v("主体校验→权责分析→违约条款评估")])]),t._v(" "),_("tr",[_("td",[t._v("法律咨询")]),t._v(" "),_("td",[t._v("事实提取→法条匹配→解决方案生成")])])])]),t._v(" "),_("ul",[_("li",[t._v("作用四：动态上下文管理")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('"""\n记忆规则：\n  - 保留核心实体（公司名/金额/时间节点）\n  - 丢弃情绪化表述（用户抱怨等）\n  - 持久化关键日期（合同截止日）\n"""\n')])])]),_("h2",{attrs:{id:"_09-system-prompt-在ai-agent如何生效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_09-system-prompt-在ai-agent如何生效"}},[t._v("#")]),t._v(" 09-System Prompt 在AI Agent如何生效")]),t._v(" "),_("p",[t._v("在AI Agent中，定义了三种核心消息类型：System Prompt、Assistant Prompt和User Prompt,三折功能明确区分：")]),t._v(" "),_("ol",[_("li",[t._v("User Prompt: 代表用户的值机输入问题")]),t._v(" "),_("li",[t._v("Assistant Prompt: 代表大模型生成的回复问题")]),t._v(" "),_("li",[t._v("System Prompt: 用于设定大模型的角色、基础指令等核心配置")])]),t._v(" "),_("p",[t._v("那么， System Prompt是如何在AI Agent中生效")]),t._v(" "),_("p",[t._v("在AIAgent中，System Prompt主要是起到静默作用，通常被置于用户输入之前，与Assistant Prompt和User Prompt组合输入到大模型中")]),t._v(" "),_("p",[t._v("System Prompt与User Prompt的关键区别在于其位置与优先级: System Prompt 固定设置在输入文本序列的开端。")]),t._v(" "),_("p",[t._v("一个完整的多轮对话提示词通常按以下模式拼接：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("System Prompt -> User Prompt -> Assistant Prompt -> User Prompt... -> Assistant Prompt\n")])])]),_("p",[t._v("在此结构中，Assisant Prompt的主要作用是向大模型展示历史对话记录，并明确标注哪些内容源于用户的输入。通过这种结构模式数据预训练和微调的大模型能够理解：这些并非即时用户输入，而是对话历史。这有利于大模型更好把握上下文信息，从而更准确回应后续问题。")]),t._v(" "),_("ol",[_("li",[t._v("将核心角色定义和规则置于System Prompt中")]),t._v(" "),_("li",[t._v("用户交互内容放在User Prompt里")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("[\n      {\n        role: 'system',\n        content: this.cachePrompt,\n      },\n      {\n        role: 'user',\n        content: query,\n      },\n];\n")])])]),_("h2",{attrs:{id:"_10-ai-search和普通search有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-ai-search和普通search有什么区别"}},[t._v("#")]),t._v(" 10-AI Search和普通Search有什么区别")]),t._v(" "),_("ul",[_("li",[t._v("本质区别在于是否具备语义理解、动态决策和主动推动能力")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("维度")]),t._v(" "),_("th",[t._v("传统搜索")]),t._v(" "),_("th",[t._v("AI Search")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("技术基础")]),t._v(" "),_("td",[t._v("关键词匹配 + 倒排索引")]),t._v(" "),_("td",[t._v("LLM + 知识图谱 + 强化学习")])]),t._v(" "),_("tr",[_("td",[t._v("交互方式")]),t._v(" "),_("td",[t._v("用户输入明确关键词->返回匹配结果")]),t._v(" "),_("td",[t._v("自然语言提问 -> 理解意图 -> 动态推理答案")])]),t._v(" "),_("tr",[_("td",[t._v("输出形式")]),t._v(" "),_("td",[t._v("链接列表(需用户二次筛选)")]),t._v(" "),_("td",[t._v("结构化答案 + 多模态结果 + 溯源依据")])]),t._v(" "),_("tr",[_("td",[t._v("目的")]),t._v(" "),_("td",[t._v("快速检索已有的信息")]),t._v(" "),_("td",[t._v("解决问题(甚至执行动作)")])])])]),t._v(" "),_("ul",[_("li",[t._v("核心能力差异\n"),_("ul",[_("li",[t._v("语义理解vs 字符匹配\n"),_("ul",[_("li",[t._v("传统:匹配关键词出现频率")]),t._v(" "),_("li",[t._v("AI-Search:理解上下文和隐含需求")])])]),t._v(" "),_("li",[t._v("静态检索vs动态推理\n"),_("ul",[_("li",[t._v("传统搜索：仅聚合现有内容")]),t._v(" "),_("li",[t._v("AI-Search:智能体模式")])])])])])]),t._v(" "),_("h2",{attrs:{id:"_11-什么是deepsearch"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么是deepsearch"}},[t._v("#")]),t._v(" 11-什么是DeepSearch")]),t._v(" "),_("p",[t._v("DeepSeach的核心理念是通过在搜索、阅读、推理三个环节不断循环往复、直到找到最优答案。搜索环节利用搜索引擎探索互联网，而阅读环境则专注于对特定网页进行详尽的分析。推理环节则负责评估当前的状态，并决定是应该将原始问题拆解为更小的子问题")]),t._v(" "),_("h2",{attrs:{id:"_12-ai-agent和ai-workflow的区别在哪里"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-ai-agent和ai-workflow的区别在哪里"}},[t._v("#")]),t._v(" 12-AI Agent和AI Workflow的区别在哪里")]),t._v(" "),_("p",[t._v("AI Workflow的运行过程都是预定义设计好的，AI Agent是运行时进行自主决策。我们在判断一个系统到底是哪一类时，主要是看它能不能在运行过程中动态决策，而不是看system prompt等提示词有多长。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("维度")]),t._v(" "),_("th",[t._v("AI Agent")]),t._v(" "),_("th",[t._v("AI Workflow")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("本质")]),t._v(" "),_("td",[t._v("具有自主决策能力的智能实体")]),t._v(" "),_("td",[t._v("预设步骤的任务自动化流程")])]),t._v(" "),_("tr",[_("td",[t._v("类比")]),t._v(" "),_("td",[t._v("有思考能力的员工")]),t._v(" "),_("td",[t._v("工厂的流水线")])]),t._v(" "),_("tr",[_("td",[t._v("决策时间")]),t._v(" "),_("td",[t._v("设计阶段")]),t._v(" "),_("td",[t._v("运行阶段")])]),t._v(" "),_("tr",[_("td",[t._v("决策权")]),t._v(" "),_("td",[t._v("自主决策")]),t._v(" "),_("td",[t._v("按预设规则执行")])]),t._v(" "),_("tr",[_("td",[t._v("可复现性")]),t._v(" "),_("td",[t._v("稳定可复现")]),t._v(" "),_("td",[t._v("需要实时记录行动log")])]),t._v(" "),_("tr",[_("td",[t._v("运行成本")]),t._v(" "),_("td",[t._v("可精准估算")]),t._v(" "),_("td",[t._v("存在波动性")])])])]),t._v(" "),_("p",[t._v("AI Agent是”思考者“，解决做什么(what)的问题，AI Workflow 则是执行者，解决怎么做How的问题")]),t._v(" "),_("h2",{attrs:{id:"_13-在ai-agent中-function-call如何把外部工具变成大模型可以理解的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-在ai-agent中-function-call如何把外部工具变成大模型可以理解的方式"}},[t._v("#")]),t._v(" 13 -在AI Agent中，function call如何把外部工具变成大模型可以理解的方式")]),t._v(" "),_("p",[t._v("将外部工具转化为大模型可理解方式的核心机制: 接口描述标准化与执行逻辑衔接")]),t._v(" "),_("p",[t._v("实现LLM/AIGC大模型理解并调用外部工具、插件或APi的核心，在于建立一套标准化的接口描述机制，并构建一个可靠的执行桥梁。该过程包含两个关键环节：")]),t._v(" "),_("ol",[_("li",[t._v("接口描述标准化")])]),t._v(" "),_("ul",[_("li",[t._v("定义结构化描述：为每个工具设计一个符合特定调用格式(常用如JSON/XML Schema)的结构化接口定义。该Schema必须清晰包含以下要素：\n"),_("ul",[_("li",[t._v("唯一标识符")]),t._v(" "),_("li",[t._v("功能说明书")]),t._v(" "),_("li",[t._v("参数规格")])])])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("执行逻辑衔接")])]),t._v(" "),_("ul",[_("li",[t._v("向大模型提供工具目录: 在每次模型交互时，将当前所有可用工具的标准化描述作为上下文信息，整合到提示词信息的特定部分传递给大模型")]),t._v(" "),_("li",[t._v("解析模型调用指令：应用程序持续监听模型的输出响应。一旦检测到符合预定义格式(如特定JSON/XML结构)的函数调用指定，立即进行解析")]),t._v(" "),_("li",[t._v("定位并执行目标工具：根据解析出的工具标识符，定位到对应的外部工具/插件/API实现")]),t._v(" "),_("li",[t._v("参数映射与校验: 从调用指令的参数列表中提取参数值，执行必要的类型转换和有效性校验，最终调用实际工具的接口")]),t._v(" "),_("li",[t._v("获取与处理执行结果：捕获工具执行后的结果")]),t._v(" "),_("li",[t._v("结果反馈闭环：将工具执行的结果格式化为文本信息，再次输入给大模型。")])]),t._v(" "),_("p",[t._v("本质概括：该机制的核心是为每个外部工具创建一份清晰易懂的”自然说明书“，使模型能够理解其功能。同事，建立一个“翻译与执行层“，负责将大模型依据说明书生成的操作指令（JSON/XML Call） 翻译并转化为对实际工具的具体调用动作，并将工具的操作结果报告翻译回大模型能够处理的信息")]),t._v(" "),_("h2",{attrs:{id:"_14-在ai-agent中-大模型如何学习到function-calling能力"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-在ai-agent中-大模型如何学习到function-calling能力"}},[t._v("#")]),t._v(" 14-在AI Agent中，大模型如何学习到Function Calling能力？")]),t._v(" "),_("p",[t._v("Function Calling 能力不是LLM/AIGC大模型原生具备的，当前AI主流的方式是通过监督微调(SUpervised Fine-tuning, SFT)来实现LLM/AIGC大模型对Function Calling能力的学习。")]),t._v(" "),_("p",[t._v("Function Calling 能力微调训练的核心思想：")]),t._v(" "),_("ol",[_("li",[t._v("获取识别意图：理解用户的请求是否需要借助外部工具/函数来完成，而不是直接生成文本回答。")]),t._v(" "),_("li",[t._v("获取参数提取与格式化能力：如果需要调用函数，正确的从用户请求中抽取出所需的参数，并按照预先定义的格式(JSON/XML)生成函数调用的指令。")])]),t._v(" "),_("p",[t._v("Function Calling的微调过程：")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("数据集制作")]),t._v("：一个用户请求，可以是包含调用函数的内容，也可以是不包含调用函数的内容。比如：给我写一首大气的诗.")])]),t._v(" "),_("ul",[_("li",[t._v("可用函数/工具描述：一个结构化的描述，告知大模型当前有哪些函数可用，每个函数的用途，所需参数以及类型和描述。这个描述本身通常就是文本，需要设计一个清晰的格式(JSON,XML)")]),t._v(" "),_("li",[t._v("期望的输出：如果需要调用函数：一个特定格式的字符串，通常是包含函数名和提取出的参数的JSON、XML对象；如果不需要调用函数、大模型直接生成文本回答。")]),t._v(" "),_("li",[t._v("数据集整体质量要求：")]),t._v(" "),_("li",[t._v("数据多样性：需要足够多、覆盖各种场景的高质量数据")]),t._v(" "),_("li",[t._v("函数描述的清晰度：函数描述的质量直接影响模型能否正确理解和使用函数")]),t._v(" "),_("li",[t._v("负样本：需要包含足够多明确不需要调用Function的样本，防止模型”过渡触发“Function调用")])]),t._v(" "),_("p",[t._v("Function 参数结构化格式例子：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('{\n"name": "get_stock_change",\n"arguments": {\n  "stock_name": "腾讯股票",\n}\n}\n')])])]),_("p",[t._v("数据集格式")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('{\n    "conversations": [\n        {\n            "from": "human",\n            "value": "帮我查询一下今天股票的涨跌幅情况?"\n        },\n        {\n            "from": "gpt",\n            "value": "当然，我可以帮忙，请问你对哪只股票感情兴趣?"\n        },\n        {\n            "from": "human",\n            "value": "腾讯股票"\n        },\n        {\n            "from": "gpt",\n            "value": "{\\n\\"function\\": \\"get_stock_change\\",\\n\\"arguments\\": {\\n\\"stock_name\\": \\"腾讯股票\\"\\n}\\n}"\n        }\n    ]\n}\n')])])]),_("ol",{attrs:{start:"2"}},[_("li",[_("strong",[t._v("选择基础模型")]),t._v(":选择一个具备强大指令遵循能力的预训练LLM/AIGC大模型")]),t._v(" "),_("li",[_("strong",[t._v("格式化训练")]),t._v('：将每条数据样本组合成大模型可以理解的格式。通常是将数据集中的"用户输入"和”可用函数/工具描述“拼接起来作为模型输入，将期望的输出作为目标输出。需要使用特定的分割符或模板来区分不同部分。')]),t._v(" "),_("li",[t._v("进行微调训练：使用标准的SFT方法(全参数微调或者训练LoRA)在特定数据集上进行微调训练。大模型的优化目标是最小化预测输出和期望输出之间的差异。大模型通过学习这些样本，学会根据用户输入和可用函数描述，决定是直接回答还是生成特定格式的函数调用JSON、XML")])]),t._v(" "),_("h2",{attrs:{id:"_15-当前-ai-agent-有哪些局限性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-当前-ai-agent-有哪些局限性"}},[t._v("#")]),t._v(" 15- 当前 AI Agent 有哪些局限性")]),t._v(" "),_("ol",[_("li",[t._v("AI Agent的幻觉问题：AI Agent中的核心LLM/AIGC大模型可能会生成不准确的信息")]),t._v(" "),_("li",[t._v("上下文长度与规划缺陷：LLM/AIGC大模型的上下文窗口有限，导致AI Agent难以处理长期有效任务和自我反思")]),t._v(" "),_("li",[t._v("多模态处理能力不成熟：不管是B端还是C端场景，很多需求都是处理图像、文本、视频、音频等异构数据，但是多数AI Agent仍以文本这个单一模态为主")]),t._v(" "),_("li",[t._v("行业适配困难：企业级场景要求零失误，但通常AI Agent容错率高，难以满足医疗、金融等高风险领域需求。垂直行业业务逻辑复杂，需深度绑定数据与流程。")]),t._v(" "),_("li",[t._v("计算成本高： AI Agent运行推理会消耗大量计算资源。")])]),t._v(" "),_("h2",{attrs:{id:"_16-当前-ai-agent有哪些主流的评价指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-当前-ai-agent有哪些主流的评价指标"}},[t._v("#")]),t._v(" 16- 当前 AI Agent有哪些主流的评价指标")]),t._v(" "),_("ol",[_("li",[t._v("任务成功率：层级任务完成率、郭晨轨迹精确度、长周期策略稳定性等")]),t._v(" "),_("li",[t._v("工具调用准确率")]),t._v(" "),_("li",[t._v("推理质量")]),t._v(" "),_("li",[t._v("用户满意度")])]),t._v(" "),_("h2",{attrs:{id:"_17-ai-agent如何具备长期记忆能力"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-ai-agent如何具备长期记忆能力"}},[t._v("#")]),t._v(" 17-. AI Agent如何具备长期记忆能力？")]),t._v(" "),_("p",[t._v("要让AI Agent具备长期记忆能力，需要解决LLM/AIGC大模型固有的上下文窗口限制和无状态缺陷")]),t._v(" "),_("p",[t._v("具备长期记忆的AI Agent需要采用 分层存储 + 智能检索 架构，核心是通过向量化、摘要压缩、混合数据库 打破上下文窗口限制")]),t._v(" "),_("ol",[_("li",[t._v("长期记忆的架构设计")])]),t._v(" "),_("ul",[_("li",[t._v("AI Agent的记忆需模拟人脑结构，分为三层协同工作：")]),t._v(" "),_("li",[t._v("短期记忆：通过上下文窗口(如transfor的token限制)维持当前对话连贯性，但容量有限制(通常4k-128k token)")]),t._v(" "),_("li",[t._v("中期记忆：将对话关键信息压缩为摘要或嵌入向量，存储于向量数据库，支持语义检索")]),t._v(" "),_("li",[t._v("长期记忆：持久化存储用户画像、行为习惯等结构化数据，使用SQL/NoSQL数据库或者知识图谱实现跨会话记忆")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("关键实现技术")])]),t._v(" "),_("ul",[_("li",[t._v("记忆生成与压缩")]),t._v(" "),_("li",[t._v("摘要提炼\n"),_("ul",[_("li",[t._v("每次对话结束后，用专用LLM生成摘要")])])]),t._v(" "),_("li",[t._v("嵌入向量化\n"),_("ul",[_("li",[t._v("通过BERT或OpenAI Embedding将文本转为向量，便于高效检索")])])]),t._v(" "),_("li",[t._v("记忆检索与更新")]),t._v(" "),_("li",[t._v("多模态检索：结合语义搜索(向量相似度) + 时间过滤(最近事件优先) + 规则筛选(如重要度评分)")]),t._v(" "),_("li",[t._v("冲突消解：当新旧记忆矛盾时，由LLM裁决或设置衰减权重")]),t._v(" "),_("li",[t._v("记忆集成至Agent\n将检索结果动态注入Prompt")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("m.add(user_query, user_id='Alice)\nrelated_memories = m.search('推荐电影', user_id='Alice') #检索相关记忆\nprompt = f\"User's historical preferences: {related_memories}. Current query: {new_query}\"\nresponse = llm.generate()\n")])])]),_("h2",{attrs:{id:"_18-ai-agent中的以及机制的原理与作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-ai-agent中的以及机制的原理与作用"}},[t._v("#")]),t._v(" 18- AI Agent中的以及机制的原理与作用")]),t._v(" "),_("ol",[_("li",[t._v("为什么需要记忆？ - 从金鱼脑说起")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("你：我叫小明，我喜欢打篮球。\nAI：你好小明！打篮球是一项很棒的运动。\n你：我最好的朋友叫小王。\nAI：小王听起来是个不错的朋友。\n你：那我和小王周末经常一起做什么？\n")])])]),_("p",[t._v("这时，AI不会记忆之前的对话，就像是一条只有7秒记忆的金鱼。")]),t._v(" "),_("p",[t._v("核心问题：标准的LLM是”无状态“的，每次对话，它都只基于你当前输入的提示词来生成回答，一旦对话结束，这些上下文信息就蒸发了")]),t._v(" "),_("p",[t._v("而一个真正的AI Agent，是需要执行复杂的，多步骤任务的(比如帮你规划整个旅行行程，作为客服处理一个完整的客诉，作为游戏角色与你长期互动)。如果它没有记忆，每一步都像是从头开始。")]),t._v(" "),_("p",[t._v("所以。记忆机制就是为了让AI Agent拥有持续学习、积累经验，并基于完整上下文进行决策的能力。")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("记忆机制的原理：它如何工作？")])]),t._v(" "),_("ul",[_("li",[t._v("记忆的类型(像大脑的不同功能区)")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v(" - 短期记忆：\n  - 是什么：相当于Agent的工作台或者大脑当前活跃区域。它保存着当前任务直接相关的、最近的信息\n  - 技术实现：通常就是对话上下文。当你与Agent聊天时，你之前说的N句话(比如最近10轮对话)会作为提示词的一部分，一起送到模型，让它知道刚才我们聊了什么\n- 长期记忆\n - 是什么：相当于Agent的个人日记或知识库。它存储着需要被长期保留的重要信息，比如你的个人偏好，从过往任务重学到的经验，关于世界的事实\n - 技术实现：一个外部向量数据库。这是记忆系统的核心。\n  - 步骤1：编码:当AI认为某段信息很重要，他会通过一个模型将这段时间转换为一串数字\n  - 步骤2：存储：将这串数字和对应的原始文本一起存入数据库\n  - 步骤3：检索：当需要用到记忆时，AI会将当前问题也转换为向量，然后在数据库里搜索语义上最相关的向量片段\n")])])]),_("ul",[_("li",[t._v("记忆的流动：一个完整的闭环一个配置了记忆机制的AI Agent，其工作流程是这样的：感知 -> 思考 -> 行动 -> 记忆 的循环\n"),_("ul",[_("li",[t._v("感知： Agent接收到新的信息")]),t._v(" "),_("li",[t._v("检索：Agent自动从长期记忆库中搜索相关的记忆")]),t._v(" "),_("li",[t._v("思考：Agent将新的输入 + 检索到的长期记忆 + 当前的短期记忆组合成一个丰富的提示词，送给大语言模型进行推理")]),t._v(" "),_("li",[t._v("行动：大语言模型基于完整的上下文，生成回答")]),t._v(" "),_("li",[t._v("记忆：Agent决定是否将这次交互中有价值的信息存储到长期记忆中，以备将来使用。同时，这次对话本身进入了短期记忆的上下文窗口")])])])]),t._v(" "),_("p",[t._v("3.记忆机制的作用：它带来了什么")]),t._v(" "),_("ul",[_("li",[t._v("记忆机制从根本上提升了AI Agent的能力天花板，使其从”工具“向”伙伴“演进\n"),_("ul",[_("li",[_("ol",[_("li",[t._v("实现连续性与个性化")])]),t._v(" "),_("ul",[_("li",[t._v("作用：让 Agent能够记住用户的身份、偏好、习惯和历史互动。你不需要在每次对话中重复介绍自己")])])]),t._v(" "),_("li",[t._v("积累与学习能力\n"),_("ul",[_("li",[t._v("作用： Agent可以从过去的成功与失败中学习。它可以把解决过的问题和方法存入记忆，下次遇到类似情况时，直接调用，提高效率")])])]),t._v(" "),_("li",[t._v("维持状态与上下文\n"),_("ul",[_("li",[t._v("作用：在复杂的多步骤中，记忆机制帮助Agent维持任务的状态，知道我已经完成了哪几部，下一步该做什么")])])]),t._v(" "),_("li",[t._v("支持复杂推理与规划\n"),_("ul",[_("li",[t._v("作用：只有拥有丰富的背景知识，才能进行深度的、基于上下文的推理和长远规划")])])])])])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("一个生动的比喻：图书管理员")])]),t._v(" "),_("p",[t._v("可以把AIAgent的记忆机制想象成一个超级图书馆管理员")]),t._v(" "),_("ul",[_("li",[t._v("大语言模型：是这位管理员本身的知识和口才")]),t._v(" "),_("li",[t._v("短期记忆：是他手边正在翻阅的那几本书")]),t._v(" "),_("li",[t._v("长期记忆：是整个庞大的图书馆藏书")]),t._v(" "),_("li",[t._v("检索记忆：是管理员掌握的高效图书检索系统。当他需要回答时，他会先用自己的口才（LLM），结合手边的书(短期记忆)，同时用检索系统 从图书馆（长期记忆）找到最相关的书籍来佐证，最后给出一个完美的答案。")])]),t._v(" "),_("p",[t._v("总结：\n记忆机制是AI Agent的灵魂档案室，它将大语言模型一次性，孤立的智能，转变成了持续的，进化的，具备上下文意识的智能。")]),t._v(" "),_("h2",{attrs:{id:"_19-介绍一下ai-agent的上下文工程的原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-介绍一下ai-agent的上下文工程的原理"}},[t._v("#")]),t._v(" 19- 介绍一下AI Agent的上下文工程的原理")]),t._v(" "),_("ol",[_("li",[t._v("什么是上下文工程？\n简单来说，上下文工程是指为AI Agent精心设计、组织和管理其所能接触到的信息，使其能够更准确、更连贯、更高效地完成任务的一整套方法，策略和技术。")])]),t._v(" "),_("p",[t._v("可以想象成一个非常聪明但患有”短期失忆症“的助手准备一个完美的”工作备忘录“。这个备忘录里面包含：")]),t._v(" "),_("ul",[_("li",[t._v("它要做什么(任务指令)")]),t._v(" "),_("li",[t._v("它之前做了什么(历史对话和行动)")]),t._v(" "),_("li",[t._v("它知道什么(相关知识库)")]),t._v(" "),_("li",[t._v("它能用什么(可调用的工具列表)")]),t._v(" "),_("li",[t._v("它应该注意什么(行为准则和约束)")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("为什么上下文如此重要？ - 原理的核心")])]),t._v(" "),_("p",[t._v("大模型语言工作机制：它是一种基于上下文额自回归预测模型")]),t._v(" "),_("ol",[_("li",[t._v('无状态性：LLM本身是"无状态"的。每次调用之间互不相干。它根据这个文本预测下一个最可能得词/令牌，如此循环。它没有内置的记忆来记住上一次你和它说了什么。')]),t._v(" "),_("li",[t._v("上下文窗口是唯一的”工作记忆区“：模型能够看到和处理的全部信息，就是当前这次请求所携带的上下文。这个上下文就是它的整个世界、全部的工作记忆。模型的所有推理、决策和回答，都完全基于所提供的这个上下文。")])]),t._v(" "),_("p",[t._v("因此,上下文工程的根本原理就是：通过精心控制模型的”输入信息“，来引导和约束模型的”输出行为“，从而模拟出智能、连贯、有状态的代理行为。")]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("上下文的关键组成部分")])]),t._v(" "),_("p",[t._v("一个为AI Agent设计的高质量上下文，通常包含以下几个核心部分，这也是上下文工程需要精心构筑的模块")]),t._v(" "),_("ul",[_("li",[t._v("系统提示|角色设定\n"),_("ul",[_("li",[t._v("内容：定义Agent的人设，核心职责、目标和行为规范")]),t._v(" "),_("li",[t._v("作用：在任务开始时为Agent设定一个稳定的”心智模型“，告诉它”你是谁“、你该做什么以及你该如何表现")])])]),t._v(" "),_("li",[t._v("任务指令与目标\n"),_("ul",[_("li",[t._v("内容：清晰、具体地描述当前需要完成的任务")]),t._v(" "),_("li",[t._v("作用：为本次交互提供明确的方向")])])]),t._v(" "),_("li",[t._v("对话与行动历史\n"),_("ul",[_("li",[t._v("内容：记录用户与Agent之间多轮对话的完整记录，以及Agent之前调用工具/执行行动的内容和结果")]),t._v(" "),_("li",[t._v("作用：提供连贯性。让Agent能够引用之前说话的话，理解用户的指代，并避免重新操作")]),t._v(" "),_("li",[t._v("原理：这是模拟“记忆”和状态的关键。没有历史，每个问题对Agent来说都是全新的")])])]),t._v(" "),_("li",[t._v("外部知识与文档\n"),_("ul",[_("li",[t._v("内容：通过检索增强生成等技术，从向量数据库、知识库或网络中获取、与当前任务相关的信息")]),t._v(" "),_("li",[t._v("作用：弥补LLM知识的时效性和专有性不足，为其决策提供事实依据。")])])]),t._v(" "),_("li",[t._v("工具与函数定义\n"),_("ul",[_("li",[t._v("内容：描述Agent可以调用的外部工具的列表，包括他们的名称、描述、参数格式等")]),t._v(" "),_("li",[t._v("作用：扩展Agent的行动能力，使其不在局限于文本生成，而是可以执行具体操作")]),t._v(" "),_("li",[t._v("原理：通过提供工具描述，引导模型在遇到特定情况时选择并结构化调用正确的工具")])])]),t._v(" "),_("li",[t._v("结构化输出要求\n"),_("ul",[_("li",[t._v("内容：要求模型以特定的格式输出其思考过程或最终答案")]),t._v(" "),_("li",[t._v("作用：便于后端的程序解析模型的输出，实现自动化流程。这对于Agent的“思考-行动”循环至关重要")])])])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("上下文工程的核心原理和策略")])]),t._v(" "),_("p",[t._v("原理1： 分层与优先级\n上下文窗口是有限的宝贵资源。必须高效利用")]),t._v(" "),_("ul",[_("li",[t._v("策略")]),t._v(" "),_("li",[t._v("系统提示优先且稳定：系统提示通常放在最前面，并且在整个会话中尽量保持稳定，它是Agent的基石")]),t._v(" "),_("li",[t._v("相关性筛选：不是所有的历史记录和外部知识都同样重要。使用检索器根据当前问题，动态地从海量信息中找出最相关的片段放入上下文。这是RAG的核心")]),t._v(" "),_("li",[t._v("历史摘要/压缩：当对话很长时，将遥远的对话历史压缩陈一个简洁的摘要，而不是完整地保留所有的原始文本，以节省空间。")])]),t._v(" "),_("p",[t._v("原理2：思维过程与推理框架\n要让Agent完成复杂任务，需要引导它进行逐步推理")]),t._v(" "),_("ul",[_("li",[t._v("策略：\n"),_("ul",[_("li",[t._v("在上下文中提供思考模板：通过在系统提示中明确要求Agent按照思考-行动-观察的步骤来工作\n"),_("ul",[_("li",[t._v("思考：分析现状，决定下一步做什么")]),t._v(" "),_("li",[t._v("行动：调用工具或生成回答")]),t._v(" "),_("li",[t._v("观察：记录行动的结果")]),t._v(" "),_("li",[t._v("示例（ReAct模式）")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("思考：用户需要知道北京的天气来决定是否带伞。我知道当前日期，但不知道实时天气。我需要调用天气查询工具。\n")])])])])])])]),t._v(" "),_("p",[t._v('行动：调用工具[get_weather(城市="北京")]\n观察：工具返回结果：北京，晴，气温25°C。\n思考：根据天气信息，北京是晴天，不需要带伞。我可以把这个信息告诉用户。\n回答：北京今天是晴天，气温25°C，出门不需要带伞哦！\n```\n- 通过将这种结构化的思考过程也放入上下文中(通过是模型的输出中)，我们迫使模型进行更深入，更逻辑化的推理，而不仅仅是给出最终答案')]),t._v(" "),_("p",[t._v("原理3：动态管理与状态维持\n由于上下文窗口的限制与任务的长期性，上下文必须是动态变化的")]),t._v(" "),_("ul",[_("li",[t._v("策略：\n"),_("ul",[_("li",[t._v("滑动窗口：只保留最近N轮对话，丢弃最老的对话。简单但可能丢失关键长期信息")]),t._v(" "),_("li",[t._v("智能摘要: 如上所述，由Agent或一个单独的流程定期对过去的交互进行总结，将摘要而非全文放入上下文。")]),t._v(" "),_("li",[t._v("向量化长期记忆：将重要的用户信息、任务状态等存储在外部数据库。等需要时，再通过检索的方式将其拉回上下文。这实现了长期记忆与工作记忆的分离")])])])]),t._v(" "),_("h2",{attrs:{id:"_20-主流的ai-agent"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-主流的ai-agent"}},[t._v("#")]),t._v(" 20 -主流的AI Agent")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("框架名称")]),t._v(" "),_("th",[t._v("执核心特点特征")]),t._v(" "),_("th",[t._v("典型应用场景")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("LangChain")]),t._v(" "),_("td",[t._v("模块化组件、生态丰富，链式编排工作流")]),t._v(" "),_("td",[t._v("快速原型验证，高度定制的单Agent应用，如文档问答，客服自动化")])]),t._v(" "),_("tr",[_("td",[t._v("LangGraph")]),t._v(" "),_("td",[t._v("基于图的工作流，强大的状态管理和循环控制")]),t._v(" "),_("td",[t._v("复杂决策系统，多Agent协调，长周期任务")])]),t._v(" "),_("tr",[_("td",[t._v("CrewAI")]),t._v(" "),_("td",[t._v("角色驱动，强调智能体检的结构化分工与写作")]),t._v(" "),_("td",[t._v("内容创建，数据分析，商业策划等有明确分工的协作任务")])]),t._v(" "),_("tr",[_("td",[t._v("AutoGen")]),t._v(" "),_("td",[t._v("对话驱动，通过多轮自然语言对话实现智能体协作")]),t._v(" "),_("td",[t._v("研究探索，代码生成，需要创建新思维的场景")])]),t._v(" "),_("tr",[_("td",[t._v("Semantic Kernel")]),t._v(" "),_("td",[t._v("企业级集成，强大的安全合规性，插件架构")]),t._v(" "),_("td",[t._v("现有系统的智能化改造")])]),t._v(" "),_("tr",[_("td",[t._v("Dify")]),t._v(" "),_("td",[t._v("低代码/零代码，可视化界面，快速构建和部署")]),t._v(" "),_("td",[t._v("中小企业快速构建知识库问答，快速原型")])]),t._v(" "),_("tr",[_("td",[t._v("OpenAI Agents SDK")]),t._v(" "),_("td",[t._v("轻量级，支持多模型，内置调式工具")]),t._v(" "),_("td",[t._v("邮件优雅的多代理系统")])])])]),t._v(" "),_("h2",{attrs:{id:"_21-主流的ai-agent中包含哪些核心模块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_21-主流的ai-agent中包含哪些核心模块"}},[t._v("#")]),t._v(" 21- 主流的AI Agent中包含哪些核心模块")]),t._v(" "),_("p",[t._v("五大核心模块")]),t._v(" "),_("ol",[_("li",[t._v("规划模块：这是AI Agent的大脑，负责思考与决策")])]),t._v(" "),_("ul",[_("li",[t._v("任务分解：将负责的用户指令拆解成一系列可执行的子任务")]),t._v(" "),_("li",[t._v("战略制定：规划完整任务的最佳路线和顺序，处理子任务之间的依赖关系")]),t._v(" "),_("li",[t._v("反思与校准：在行动过程中或结束后，评估当前结果是否满足要求，并进行自我纠正。这是实现复杂任务的关键")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("工具使用模块")])]),t._v(" "),_("ul",[_("li",[t._v("工具库：一个Agent可以调用的外部工具，API或函数的集合")]),t._v(" "),_("li",[t._v("调用和执行：Agent 根据规划模块的决策，选择正确的工具，生成正确的参数，并执行调用")]),t._v(" "),_("li",[t._v("结果处理：接收工具返回的结果，并将其标准化，传递给其他模块")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("记忆模块\n这是Agent的经验库，用户存储和检索信息，分为")])]),t._v(" "),_("ul",[_("li",[t._v("短期记忆：保留当前对话或任务链的上下文，确保对话的关联性")]),t._v(" "),_("li",[t._v("长期记忆：通过向量数据库等技术，保存跨对话的长期知识、用户偏好、历史决策和结果，供未来任务参考。")])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("行动输出模块\n这是Agent的最终表达。将内部决策转化为用户可感知的输出")])]),t._v(" "),_("ul",[_("li",[t._v("生成最终答案：在不需要调用工具或所有步骤完成后，生成自然语言回复")]),t._v(" "),_("li",[t._v("生成结构化指令：当需要与环境交互时，生成工具调用的指令")]),t._v(" "),_("li",[t._v("交付最终话结果：例如:返回一篇写完的文章，一段生成的代码，一个创建好的文件等")])]),t._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[_("p",[t._v("串联模块的灵魂：感知与推理循环\n单独拥有这些模块还不够，最关键的是让它们运转起来的核心控制流，即感知-思考行动循环，这通常由大模型的推理能力驱动")])]),t._v(" "),_("li",[_("p",[t._v("感知：接收用户输入和环境的反馈")])]),t._v(" "),_("li",[_("p",[t._v("思考")])])]),t._v(" "),_("ul",[_("li",[t._v("规划模块结合记忆模块（历史上下文和知识）：决定下一步该做什么")]),t._v(" "),_("li",[t._v("如果需要外部工具，工具使用模块被激活")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("行动")])]),t._v(" "),_("ul",[_("li",[t._v("工具使用模块执行调用，并将结果协会记忆模块")]),t._v(" "),_("li",[t._v("规划模块：根据结果进行反思，判断任务是否完成。如果未完成，回到第二步继续思考，如果完成，则通过行动输出模块给出最终结果")])]),t._v(" "),_("p",[t._v("一个AI Agent的智能程度不仅取决于其核心大模型的能力，更取决于这些大模型设计的精巧程度与协作效率")]),t._v(" "),_("h2",{attrs:{id:"_22-ai-agent中memory和rag有哪些区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_22-ai-agent中memory和rag有哪些区别"}},[t._v("#")]),t._v(" 22- AI Agent中Memory和RAG有哪些区别")]),t._v(" "),_("p",[t._v("AI Agent中Memory和RAG的本质区别")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("维度")]),t._v(" "),_("th",[t._v("Memory")]),t._v(" "),_("th",[t._v("RAG")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("核心目的")]),t._v(" "),_("td",[t._v("维持AI Agent的连续性、个性化和状态感知")]),t._v(" "),_("td",[t._v("提供外部知识检索以增强生成能力")])]),t._v(" "),_("tr",[_("td",[t._v("存储内容")]),t._v(" "),_("td",[t._v("会话历史、用户偏好、行动轨迹、内部状态")]),t._v(" "),_("td",[t._v("结构化/非结构化文档、知识库、事实数据")])]),t._v(" "),_("tr",[_("td",[t._v("时间维度")]),t._v(" "),_("td",[t._v("短期+长期记忆，具备时间序列特性")]),t._v(" "),_("td",[t._v("静态知识，通常不随时间频繁变化")])]),t._v(" "),_("tr",[_("td",[t._v("更新频率")]),t._v(" "),_("td",[t._v("实时、高频")]),t._v(" "),_("td",[t._v("低频、批量更新")])]),t._v(" "),_("tr",[_("td",[t._v("数据结构")]),t._v(" "),_("td",[t._v("图结构、序列结构、键值对、向量")]),t._v(" "),_("td",[t._v("文档、向量、索引结构")])])])]),t._v(" "),_("p",[_("strong",[t._v("技术架构对比")])]),t._v(" "),_("ol",[_("li",[t._v("Memory机制")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("class AgentMemory:\n  def _init_(self):\n    // 短期记忆(对话上下文)\n    self.short_term = []\n\n    // 长期记忆(向量存储)\n    self.long_term = VectorStore()\n\n    // 经验记忆(强化学习)\n    self.experience = ExperienceReplay()\n\n    // 工作记忆(当前任务状态)\n    self.working = TaskState()\n\n# 关键组件\n# - 对话历史管理\n# - 状态跟踪器\n# - 经验回放缓冲池\n# - 记忆压缩/遗忘机制\n# - 记忆检索和关联\n")])])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("RAG系统")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("# 典型RAG架构\nclass RAGSystem:\n  def _init_(self):\n    // 文档处理流水器\n    self.doc_processor = DocumentProcessor()\n\n    # 向量化模型\n    self.embedder = EmbeddingModel()\n\n    #向量数据库\n    self.vector_db = VectorDatabase()\n\n    #检索器\n    self.retriever = Retriever()\n\n    # 重排器\n    self.reranker = Reranker()\n\n# 关键组件\n# - 文档分割和清晰\n# - 向量索引构建\n# - 相似性搜索算法\n# - 上下文压缩和重组\n# - 多跳检索能力\n")])])]),_("p",[_("strong",[t._v("功能差异详细分析")])]),t._v(" "),_("ul",[_("li",[t._v("Memory的核心功能\n"),_("ul",[_("li",[t._v("会话连续性"),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('memory = [\n  {"role": "user", "content": "我喜欢科幻电影"},\n  {"role": "assistant", "content": "推荐《星际穿越》"},\n  {"role": "user", "content": "还有类似的吗"}, # 这里依赖记忆\n]\n')])])])]),t._v(" "),_("li",[t._v("个性化适配\n"),_("ul",[_("li",[t._v("学习用户偏好")]),t._v(" "),_("li",[t._v("适应交互风格")]),t._v(" "),_("li",[t._v("记住用户特定信息")])])]),t._v(" "),_("li",[t._v("状态保持")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 任务状态记忆\ntask_state = {\n "current_step": 3,\n "completed_steps": ["收集需求", "分析数据", "生成大纲"],\n "next_action": "编写执行计划",\n "constraints": ["预算限制: $100", "时间限制：7天"],\n}\n')])])]),_("ul",[_("li",[t._v("经验学习")]),t._v(" "),_("li",[t._v("从成功/失败中学习")]),t._v(" "),_("li",[t._v("优化决策策略")]),t._v(" "),_("li",[t._v("形成肌肉记忆")])])])]),t._v(" "),_("p",[_("strong",[t._v("RAG的核心功能")])]),t._v(" "),_("ul",[_("li",[t._v("知识检索")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('  #从知识库检索相关信息\n  query = "如何修复PostgreSQL连接错误？"\n  retrieved_docs = vector_db.similarity_search(\n    query=query,\n    k=5, # 返回5个最相关文档\n    filter={"source": "官方文档"}\n  )\n')])])]),_("ul",[_("li",[t._v("事实增强\n"),_("ul",[_("li",[t._v("提供最新信息(避免LLM知识过时)")]),t._v(" "),_("li",[t._v("提供详细数据(统计数字、技术细节等)")]),t._v(" "),_("li",[t._v("提供权威来源引用")])])]),t._v(" "),_("li",[t._v("领域专业化"),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('  # 专业领域知识搜索\n  medical_rag = RAGSystem(\n    docuements_medical_textbooks,\n    embedding_model="med-bert",\n    retrieval_strategy="hybrid_search"\n  )\n')])])])]),t._v(" "),_("li",[t._v("幻觉抑制\n"),_("ul",[_("li",[t._v("基于真实文档生成回答")]),t._v(" "),_("li",[t._v("提供可验证的参考风险")]),t._v(" "),_("li",[t._v("减少编造信息的风险")])])])]),t._v(" "),_("p",[_("strong",[t._v("存储和检索方式对比")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("Memory存储方式")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 1. 向量记忆\nmemory_vectors = embedder.encode([\n  \'用户偏好素食\',\n  \'用户是软件工程师\',\n  \'用户上次询问python问题\',\n])\n\n# 2. 图记忆\nmemory_graph = {\n  "user": {"likes": ["scifi", "coding"], dislikes: ["horror"]},\n  "projects": {"current": "AI Agent", completed: ["Web App"]},\n  "conversations": {"today": 5, "total": 342},\n}\n\n# 3. 序列记忆\nmemory_timeline = [\n  {"timestamp": "10:00", "action": "started_task", "details": "..."},\n  {"timestamp": "10:15", "action": "requested_data", "details": "..."},\n  {"timestamp": "10:30", "action": "completed_step", "details": "..."}\n]\n')])])])]),t._v(" "),_("li",[_("p",[t._v("RAG存储方式")])])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 文档分块和向量化\ndocuments = [\n    "PostgreSQL安装指南...",\n    "数据库优化技巧...",\n    "常见错误解决方案..."\n]\n\n# 创建向量索引\nvector_index = VectorIndex(\n  documents=documents,\n  chunk_size=500, #500字符一个块\n  overlap=50, #块间重叠50字符\n  embedding_model="text-embedding-ada-002"\n)\n\n# 支持多种检索模式\nretrieval_methods = {\n  "dense": vector_index.dense_retrieval,\n  "sparse": vector_index.bm25_retrieval,\n  "hybrid": vector_index.hybrid_retrieval,\n  "multi_vector": vector_index.multi_vector_retrieval\n}\n')])])]),_("p",[_("strong",[t._v("更新机制对比")])]),t._v(" "),_("ol",[_("li",[t._v("Memory更新特性")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("class MemoryUpdate:\n  # 1. 增量更新\n  def add_experience(self, experience)：\n    self.experience_buffer.append(experience)\n    if len(self.experience_buffer) > capacity:\n      self.compress_memory() #记忆压缩\n  # 2. 重要性加权\n  def weight_by_importance(self, memory_item):\n    # 基于使用频率、情感强度、任务相关性加权\n    importance_score = (\n      frequency * 0.3 +\n      recency * 0.2 +\n      emotional_intensity * 0.2 +\n      task_relevance * 0.3\n    )\n    return importance_score\n  \n  # 3. 选择性遗忘\n  def forget_less_important(self, threshold=0.5):\n    for item in self.memories:\n      if item.importance < threshold:\n        self.archive(item) # 归档而非删除\n\n")])])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("RAG更新特性")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('class RAGUpdate:\n # 1. 批量更新\n def update_knowledge_base(self, new_documents):\n  # 重新处理整个文档集或增量更新\n  if self.incremental_update_supported:\n    self.vector_db.add_documents(new_document)\n  else:\n    # 重新重建整个索引\n    self.rebuild_index(existing_docs + new_document)\n\n  # 2. 版本控制\n  def create_snapshot(self, version):\n    self.snapshots[version] = {\n      "document": deepcopy(self.docuemnts),\n      "index": deepcopy(self.vector_index),\n      "timestamp": datetime.now(),\n    }\n\n  # 3. 质量过滤\n  def filter_by_quality(self, document, min_quality_score= 0.7);\n    return [doc for doc in documents\n            if self.quality_score(doc) >= min_quality_score]\n')])])]),_("p",[_("strong",[t._v("检索策略差异")])]),t._v(" "),_("ol",[_("li",[t._v("Memory检索策略")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 基于上下文的关联检索\ndef retrieve_relevant_memories(self, current_context, top_k=3):\n  # 1. 时间相关性\n  recent_memories = self.get_recent_memories(hour=24)\n  # 2. 语义相关性\n  content_embeddding= self.embedder.encode(current_content)\n  similar_memories = self.vector_memory.search(\n    query_vector=context_embedding,\n    k=top_k\n  )\n  # 3. 任务相关性\n  task_related=self.get_task_memories(\n    task_type=current_context.task_type\n  )\n  # 4. 综合评分\n  scored_memories = self.rank_memories(\n    recent_memories + similar_memories + task_related,\n    weights={"recent": 0.4, "semantic": 0.4, "task": 0.2}\n  )\n')])])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("RAG检索策略")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("# 基于查询的知识检索\ndef retrieve_relevant_documents(self, query, top_k=5):\n  # 1. 密集向量查询\n  dense_results=self.vector_db.similarity_search(\n    query=query,\n    k=top_k*2\n  )\n  # 2. 稀疏检索(关键词)\n  sparse_results=self.bm25_retriever.search(\n    query=query,\n    k=top_k*2\n  )\n  # 3. 混合检索\n  hybrid_results = self.hybrid_search(\n    dense_results, sparse_results,\n    dense_weight=0.7, sparse_weight=0.3\n  )\n  # 4. 重排序\n  reranked_results = self.reranker.rerank(\n    query=query,\n    document=hybrid_results\n  )\n\n  return reranked_results[:top_k]\n")])])]),_("p",[_("strong",[t._v("实际应用场景对比")])]),t._v(" "),_("ol",[_("li",[t._v("适合使用Memory的场景")])]),t._v(" "),_("ul",[_("li",[t._v("对话系统")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("# 需要记住对话历史\nchatbot_with_memory = ChatAgent(\n  memory=ConversationMemory(max_turns=10),\n  personality=PersonalityTrait(\n    tone='friendly',\n    expertise_level='intermediate'\n  )\n)\n")])])]),_("ul",[_("li",[t._v("持续学习Agent")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("# 从经验中学习的Agent\nlearning_agent= RLAgent(\n  memory=ExperienceReplayBuffer(size=10000),\n  police_network=PoliceNet(),\n  update_frequency=100 # 每100步更新一次\n)\n")])])]),_("ul",[_("li",[t._v("个性化助手")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 记住用户偏好的助手\npersonal_assistant = Assistant(\n  memory=UserProfileMemory(\n    preferences=["素食","早起", "技术新闻"],\n    habits=["每天锻炼", "周末阅读"],\n    constraints=["对坚果过敏", "预算有限"]\n  )\n)\n')])])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("适合使用RAG的场景")])]),t._v(" "),_("ul",[_("li",[t._v("企业知识库问答")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 基于企业文档的问答\ncompany_qa=RAGSystem(\n documents= [\n   "员工手册.pdf",\n   "技术文档",\n   "项目报告",\n   "会议记录",\n ],\n retrieval_config={\n   "chunk_size": 1000,\n   "search_strategy": "hybrid",\n   "reranker": "cross-encoder",\n }\n)\n')])])]),_("ul",[_("li",[t._v("事实核查系统")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("# 验证信息的准确性\nface_checker=FaceCheckingSystem(\n knowledge_sources=[\n    WikipediaDump(),\n    NewsArticles(),\n    AcademicPapers(),\n    GovernmentReports()\n ],\n citation_required=True,\n confidence_threshold=0.8\n)\n")])])]),_("ul",[_("li",[t._v("技术文档助手")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('# 提供技术支持和文档查询\ntech_support=TechDOcAssistent(\n docs=["API文档", "教程", "FAQ", "错误代码手册"],\n search_features={\n   "code_search": True,\n   "error_code_lookup": True,\n   "version_specific": True,\n }\n)\n')])])]),_("h2",{attrs:{id:"_23-ai-agent中agents、teams、worflows三者有哪些区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_23-ai-agent中agents、teams、worflows三者有哪些区别"}},[t._v("#")]),t._v(" 23 - AI Agent中Agents、Teams、Worflows三者有哪些区别")]),t._v(" "),_("ol",[_("li",[t._v("Agents(代理)")])]),t._v(" "),_("ul",[_("li",[t._v("定义：AI程序，由LLM控制执行流程")]),t._v(" "),_("li",[t._v("核心组件:\n"),_("ul",[_("li",[t._v("Model: 控制执行流程，决定是推理、使用工具还是响应")]),t._v(" "),_("li",[t._v("Instructions: 指导模型如何使用工具和响应")]),t._v(" "),_("li",[t._v("Tools: 使模型能够执行操作并与外部系统交互")])])]),t._v(" "),_("li",[t._v("扩展能力\n"),_("ul",[_("li",[t._v("Memory: 存储和回忆之前交互的信息")]),t._v(" "),_("li",[t._v("Storage: 在数据库中保存会话历史和状态")]),t._v(" "),_("li",[t._v("Knowledge: 运行时搜索的知识库")]),t._v(" "),_("li",[t._v("Reasoning: 在响应前思考和分析结果")])])]),t._v(" "),_("li",[t._v("适应场景：单一任务执行，如问答、搜索、内容生成等")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("Teams(团队)")])]),t._v(" "),_("ul",[_("li",[t._v("定义：多个子AI Agent的集合，协同工作完成复杂任务")]),t._v(" "),_("li",[t._v("核心特性：\n"),_("ul",[_("li",[t._v("每个成员可以有不同的专场、工具和指令")]),t._v(" "),_("li",[t._v("由Team Leader协调任务分配")]),t._v(" "),_("li",[t._v("支持多种协作模式")])])]),t._v(" "),_("li",[t._v("适用场景\n"),_("ul",[_("li",[t._v("需要推理和协作的任务")]),t._v(" "),_("li",[t._v("研究和规划")]),t._v(" "),_("li",[t._v("多工具决策")]),t._v(" "),_("li",[t._v("开放性问题解决")])])])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("Worflows")])]),t._v(" "),_("ul",[_("li",[t._v("定义：通过定义的步骤编排Agents、Teams和函数，提供结构化自动化")]),t._v(" "),_("li",[t._v("核心构建块\n"),_("table",[_("thead",[_("tr",[_("th",[t._v("组件")]),t._v(" "),_("th",[t._v("用途")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("Step")]),t._v(" "),_("td",[t._v("基本执行单元")])]),t._v(" "),_("tr",[_("td",[t._v("Parallel")]),t._v(" "),_("td",[t._v("并行执行多个步骤")])]),t._v(" "),_("tr",[_("td",[t._v("Condition")]),t._v(" "),_("td",[t._v("条件执行")])]),t._v(" "),_("tr",[_("td",[t._v("Loop")]),t._v(" "),_("td",[t._v("迭代执行直到满足条件")])]),t._v(" "),_("tr",[_("td",[t._v("Router")]),t._v(" "),_("td",[t._v("动态路由选择执行路径")])])])])]),t._v(" "),_("li",[t._v("执行模式\n"),_("ul",[_("li",[t._v("顺序执行：步骤按顺序依次执行")]),t._v(" "),_("li",[t._v("并行执行：独立任务同时运行")]),t._v(" "),_("li",[t._v("条件执行：基于条件分支")]),t._v(" "),_("li",[t._v("循环迭代：迭代直到满足质量条件")]),t._v(" "),_("li",[t._v("动态路由：根据内容选择最佳路径")])])]),t._v(" "),_("li",[t._v("适用场景\n"),_("ul",[_("li",[t._v("需要确定性、可预测的多步骤执行")]),t._v(" "),_("li",[t._v("数据处理管道")]),t._v(" "),_("li",[t._v("内容创建流程")]),t._v(" "),_("li",[t._v("需要可重复、可靠的自动化流程")])])])]),t._v(" "),_("h2",{attrs:{id:"_34-ai-agent中的agentos的核心概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_34-ai-agent中的agentos的核心概念"}},[t._v("#")]),t._v(" 34 - AI Agent中的AgentOS的核心概念")]),t._v(" "),_("ol",[_("li",[t._v("什么是AgentOS\nAgentOS是AI Agent的操作系统,为Agent提供运行环境、资源管理和服务抽象层")])])])}),[],!1,null,null,null);e.default=n.exports}}]);