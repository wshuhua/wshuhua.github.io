<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基本原理 | Wsh&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/images/logo.png">
    <meta name="description" content="经常偷懒，偶尔更新的">
    
    <link rel="preload" href="/assets/css/0.styles.bc63fb2f.css" as="style"><link rel="preload" href="/assets/js/app.b9210fed.js" as="script"><link rel="preload" href="/assets/js/2.dc8a2400.js" as="script"><link rel="preload" href="/assets/js/51.3c1116c5.js" as="script"><link rel="prefetch" href="/assets/js/10.0b1da748.js"><link rel="prefetch" href="/assets/js/11.8e999e9c.js"><link rel="prefetch" href="/assets/js/12.d98e8047.js"><link rel="prefetch" href="/assets/js/13.a19f7b3e.js"><link rel="prefetch" href="/assets/js/14.bc46e720.js"><link rel="prefetch" href="/assets/js/15.77a7cb2e.js"><link rel="prefetch" href="/assets/js/16.45f3798f.js"><link rel="prefetch" href="/assets/js/17.65043558.js"><link rel="prefetch" href="/assets/js/18.60c02aca.js"><link rel="prefetch" href="/assets/js/19.f6f74a85.js"><link rel="prefetch" href="/assets/js/20.fb7a117c.js"><link rel="prefetch" href="/assets/js/21.bf9c4a2f.js"><link rel="prefetch" href="/assets/js/22.f61b5f3f.js"><link rel="prefetch" href="/assets/js/23.2a31a58d.js"><link rel="prefetch" href="/assets/js/24.b7a6c970.js"><link rel="prefetch" href="/assets/js/25.b97cbe49.js"><link rel="prefetch" href="/assets/js/26.7e90b5f9.js"><link rel="prefetch" href="/assets/js/27.153684d6.js"><link rel="prefetch" href="/assets/js/28.febd54c4.js"><link rel="prefetch" href="/assets/js/29.401b0810.js"><link rel="prefetch" href="/assets/js/3.1683544b.js"><link rel="prefetch" href="/assets/js/30.0d4a90f6.js"><link rel="prefetch" href="/assets/js/31.70c28748.js"><link rel="prefetch" href="/assets/js/32.cfc92eb6.js"><link rel="prefetch" href="/assets/js/33.59c2f9c5.js"><link rel="prefetch" href="/assets/js/34.57abc5b0.js"><link rel="prefetch" href="/assets/js/35.a5eb917d.js"><link rel="prefetch" href="/assets/js/36.12ceae77.js"><link rel="prefetch" href="/assets/js/37.db795768.js"><link rel="prefetch" href="/assets/js/38.7ff72b75.js"><link rel="prefetch" href="/assets/js/39.22113c32.js"><link rel="prefetch" href="/assets/js/4.c704e751.js"><link rel="prefetch" href="/assets/js/40.542d0ed3.js"><link rel="prefetch" href="/assets/js/41.3faa70b0.js"><link rel="prefetch" href="/assets/js/42.341637d9.js"><link rel="prefetch" href="/assets/js/43.4a4fb236.js"><link rel="prefetch" href="/assets/js/44.c849e3dc.js"><link rel="prefetch" href="/assets/js/45.41becb49.js"><link rel="prefetch" href="/assets/js/46.0ac12494.js"><link rel="prefetch" href="/assets/js/47.2e698dfe.js"><link rel="prefetch" href="/assets/js/48.2076eadc.js"><link rel="prefetch" href="/assets/js/49.5f2e0038.js"><link rel="prefetch" href="/assets/js/5.2db75e05.js"><link rel="prefetch" href="/assets/js/50.cff38e55.js"><link rel="prefetch" href="/assets/js/52.c5656eba.js"><link rel="prefetch" href="/assets/js/53.60f608a2.js"><link rel="prefetch" href="/assets/js/54.59a23ca5.js"><link rel="prefetch" href="/assets/js/55.70a0fbe3.js"><link rel="prefetch" href="/assets/js/56.c9dd2aa9.js"><link rel="prefetch" href="/assets/js/57.0bc51cac.js"><link rel="prefetch" href="/assets/js/58.accfdc8d.js"><link rel="prefetch" href="/assets/js/59.ee963ea9.js"><link rel="prefetch" href="/assets/js/6.9073f8bb.js"><link rel="prefetch" href="/assets/js/60.9ef9a297.js"><link rel="prefetch" href="/assets/js/61.10ffb3b6.js"><link rel="prefetch" href="/assets/js/62.40260df1.js"><link rel="prefetch" href="/assets/js/63.a95030cb.js"><link rel="prefetch" href="/assets/js/64.af07edb5.js"><link rel="prefetch" href="/assets/js/65.fcbd6762.js"><link rel="prefetch" href="/assets/js/66.8f07eb09.js"><link rel="prefetch" href="/assets/js/67.432e08ac.js"><link rel="prefetch" href="/assets/js/68.81e114e9.js"><link rel="prefetch" href="/assets/js/69.708928e7.js"><link rel="prefetch" href="/assets/js/7.6922c449.js"><link rel="prefetch" href="/assets/js/70.95d0b200.js"><link rel="prefetch" href="/assets/js/71.bf72ae16.js"><link rel="prefetch" href="/assets/js/72.5a2d9c13.js"><link rel="prefetch" href="/assets/js/73.d1365aa9.js"><link rel="prefetch" href="/assets/js/74.c5235ea7.js"><link rel="prefetch" href="/assets/js/75.dcd1d00d.js"><link rel="prefetch" href="/assets/js/76.57d3a9bd.js"><link rel="prefetch" href="/assets/js/77.3f938370.js"><link rel="prefetch" href="/assets/js/78.0a8f4bea.js"><link rel="prefetch" href="/assets/js/79.368892d2.js"><link rel="prefetch" href="/assets/js/8.922b3edf.js"><link rel="prefetch" href="/assets/js/80.49b05277.js"><link rel="prefetch" href="/assets/js/81.8d77f940.js"><link rel="prefetch" href="/assets/js/82.522b4616.js"><link rel="prefetch" href="/assets/js/83.9491499c.js"><link rel="prefetch" href="/assets/js/84.1aee62a9.js"><link rel="prefetch" href="/assets/js/85.1dec4854.js"><link rel="prefetch" href="/assets/js/86.2a308933.js"><link rel="prefetch" href="/assets/js/87.084bb0c1.js"><link rel="prefetch" href="/assets/js/88.e947a380.js"><link rel="prefetch" href="/assets/js/89.9b74a95d.js"><link rel="prefetch" href="/assets/js/9.c1b7ec7e.js"><link rel="prefetch" href="/assets/js/90.95ade509.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc63fb2f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/1.gif" alt="Wsh's blog" class="logo"> <span class="site-name can-hide">Wsh's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AIGC" class="dropdown-title"><a href="/aiAgent/" class="link-title">AIGC</a> <span class="title" style="display:none;">AIGC</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/aiAgent/bacis/" class="nav-link">Agent基础</a></li><li class="dropdown-item"><!----> <a href="/aiAgent/design/" class="nav-link">Agent设计模式</a></li><li class="dropdown-item"><!----> <a href="/aiAgent/model/" class="nav-link">Agent多模态</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="harmonyOS" class="dropdown-title"><a href="/harmonyOS/" class="link-title">harmonyOS</a> <span class="title" style="display:none;">harmonyOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/harmonyOS/base/" class="nav-link">基础知识</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/ArkUI/" class="nav-link">ArkUI</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/UIAbility/" class="nav-link">UIAbility</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/state/" class="nav-link">组件通信方式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">前端缓存</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">typescript</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/note/flutter/" class="nav-link">flutter</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/web3D/" class="nav-link">web3D😉</a></div><div class="nav-item"><a href="/pages/library/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/images/avatar.gif"> <div class="blogger-info"><h3>wsh</h3> <span>人未老，想养老</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AIGC" class="dropdown-title"><a href="/aiAgent/" class="link-title">AIGC</a> <span class="title" style="display:none;">AIGC</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/aiAgent/bacis/" class="nav-link">Agent基础</a></li><li class="dropdown-item"><!----> <a href="/aiAgent/design/" class="nav-link">Agent设计模式</a></li><li class="dropdown-item"><!----> <a href="/aiAgent/model/" class="nav-link">Agent多模态</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="harmonyOS" class="dropdown-title"><a href="/harmonyOS/" class="link-title">harmonyOS</a> <span class="title" style="display:none;">harmonyOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/harmonyOS/base/" class="nav-link">基础知识</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/ArkUI/" class="nav-link">ArkUI</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/UIAbility/" class="nav-link">UIAbility</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/state/" class="nav-link">组件通信方式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">前端缓存</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">typescript</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/note/flutter/" class="nav-link">flutter</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/web3D/" class="nav-link">web3D😉</a></div><div class="nav-item"><a href="/pages/library/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span> 深入浅出node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span> nest框架</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/28071e/" class="sidebar-link">框架对比</a></li><li><a href="/pages/nestJs/" class="sidebar-link">概述</a></li><li><a href="/pages/c78e85/" aria-current="page" class="active sidebar-link">基本原理</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>koa</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/tool/node/#node" data-v-0c557b5e>node</a></li><li data-v-0c557b5e><a href="/tool/node/# nest框架" data-v-0c557b5e> nest框架</a></li></ul> <div class="info" data-v-0c557b5e><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-05-09</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">基本原理<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h3 id="_01-自定义提供者"><a href="#_01-自定义提供者" class="header-anchor">#</a> 01. 自定义提供者</h3> <p>DI： 依赖注入</p> <h4 id="di的基本原理"><a href="#di的基本原理" class="header-anchor">#</a> DI的基本原理</h4> <p>依赖注入是一种反转控制（IoC）技术，将依赖的实例化委托给IoC容器（在我们的例子中，NestJS运行时系统），而不是在你自己的代码中强制进行。让我们来看看在Providers章节的这个例子中发生了什么。</p> <p>首先，我们定义一个提供者。<code>@Injectable()</code>装饰器将 CatsService 类标记为提供者。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.service.ts</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Cat <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./interfaces/cat.interface'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">readonly</span> cats<span class="token operator">:</span> Cat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Cat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cats<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，我们要求 Nest 将提供程序注入到我们的控制器类中</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.controller.tsJS</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Controller<span class="token punctuation">,</span> Get <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats.service'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Cat <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./interfaces/cat.interface'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> catsService<span class="token operator">:</span> CatsService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Cat<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后，我们在 Nest IoC 容器中注册提供程序</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.module.tsJS</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats/cats.controller'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats/cats.service'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre></div><p>这个过程有三个关键步骤:</p> <ol><li><p>在 cats.service.ts 中 <code>@Injectable()</code> 装饰器声明 CatsService 类是一个可以由Nest IoC容器管理的类。</p></li> <li><p>在 cats.controller.ts 中 CatsController 声明了一个依赖于 CatsService 令牌(token)的构造函数注入:</p></li></ol> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> catsService<span class="token operator">:</span> CatsService<span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>在 app.module.ts 中，我们将标记 CatsService与 cats.service.ts文件中的 CatsService 类相关联。 我们将在下面确切地看到这种关联（也称为注册）的发生方式。</li></ol> <p>当Nest IoC容器实例化一个CatsController时，它首先寻找任何依赖关系*。当它找到CatsService依赖时，它会对CatsService标记进行查找，根据注册步骤3 返回CatsService类。假设是SINGLETON范围（默认行为），Nest将创建一个CatsService的实例，将其缓存并返回，或者如果已经缓存了一个，则返回现有实例。</p> <p>上面这个解释稍微简化了一点。我们忽略的一个重要方面是，分析依赖项代码的过程非常复杂，并且发生在应用程序引导期间。一个关键特性是依赖关系分析(或“创建依赖关系图”)是可传递的。 在上面的示例中，如果 CatsService 本身具有依赖项，那么那些依赖项也将得到解决。 依赖关系图确保以正确的顺序解决依赖关系-本质上是<code>自下而上</code>。 这种机制使开发人员不必管理此类复杂的依赖关系图。</p> <h4 id="标准提供者"><a href="#标准提供者" class="header-anchor">#</a> 标准提供者</h4> <p>让我们仔细看看 @Module()装饰器。在app.module中，我们声明：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>providers属性接受一个提供者数组。到目前为止，我们已经通过一个类名列表提供了这些提供者。实际上，该语法providers: [CatsService]是更完整语法的简写：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>providers<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    provide<span class="token operator">:</span> CatsService<span class="token punctuation">,</span>
    useClass<span class="token operator">:</span> CatsService<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们看到了这个显式的构造，我们可以理解注册过程。在这里，我们明确地将令牌 CatsService与类 CatsService 关联起来。简写表示法只是为了简化最常见的用例，其中令牌用于请求同名类的实例。</p> <h4 id="自定义提供者"><a href="#自定义提供者" class="header-anchor">#</a> 自定义提供者</h4> <p>当您的要求超出标准提供商所提供的要求时，会发生什么？这里有一些例子：</p> <p>您要创建自定义实例，而不是让 Nest 实例化（或返回其缓存实例）类
您想在第二个依赖项中重用现有的类
您想使用模拟版本覆盖类进行测试。</p> <p>Nest允许你定义自定义提供者来处理这些情况。它提供了几种方法来定义自定义提供者。</p> <h4 id="值提供者-usevalue"><a href="#值提供者-usevalue" class="header-anchor">#</a> 值提供者 (useValue)</h4> <p><code>useValue</code> 语法对于注入常量值、将外部库放入 Nest 容器或使用模拟对象替换实际实现非常有用。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> CatsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats.service'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> mockCatsService <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">/* mock implementation
  ...
  */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>CatsModule<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      provide<span class="token operator">:</span> CatsService<span class="token punctuation">,</span>
      useValue<span class="token operator">:</span> mockCatsService<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，CatsService标记将解析为mockCatsService模拟对象。 useValue需要一个值--在这个例子中是一个具有与它所取代的CatsService类相同接口的文字对象。</p> <h4 id="非类提供者"><a href="#非类提供者" class="header-anchor">#</a> 非类提供者</h4> <p>到目前为止，我们已经使用了类名作为我们的提供者标记（ providers 数组中列出的提供者中的 Provide 属性的值）。 这与基于构造函数的注入所使用的标准模式相匹配，其中令牌也是类名。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> connection <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./connection'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      provide<span class="token operator">:</span> <span class="token string">'CONNECTION'</span><span class="token punctuation">,</span>
      useValue<span class="token operator">:</span> connection<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>在本例中，我们将字符串值令牌('CONNECTION')与从外部文件导入的已存在的连接对象相关联。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsRepository</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token string">'CONNECTION'</span><span class="token punctuation">)</span> connection<span class="token operator">:</span> Connection<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="类提供者-useclass"><a href="#类提供者-useclass" class="header-anchor">#</a> 类提供者：useClass</h4> <p>useClass语法允许你动态地确定一个令牌应该解析到的类。例如，假设我们有一个抽象的（或默认的）ConfigService类。根据当前的环境，我们希望Nest能提供不同的配置服务的实现。下面的代码实现了这样一个策略。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> configServiceProvider <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> ConfigService<span class="token punctuation">,</span>
  useClass<span class="token operator">:</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">'development'</span>
      <span class="token operator">?</span> DevelopmentConfigService
      <span class="token operator">:</span> ProductionConfigService<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>configServiceProvider<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>我们首先定义对象 configServiceProvider，然后将其传递给模块装饰器的 providers 属性。 这只是一些代码组织，但是在功能上等同于我们到目前为止在本章中使用的示例。</p> <p>另外，我们使用 ConfigService 类名称作为令牌。 对于任何依赖 ConfigService 的类，Nest 都会注入提供的类的实例（ DevelopmentConfigService 或 ProductionConfigService），该实例将覆盖在其他地方已声明的任何默认实现（例如，使用 @Injectable() 装饰器声明的 ConfigService）。</p> <h4 id="工厂提供者-usefactory"><a href="#工厂提供者-usefactory" class="header-anchor">#</a> 工厂提供者(useFactory)</h4> <p><code>useFactory</code>语法允许动态地创建提供者。实际的提供者将由工厂函数返回的值提供。工厂函数可以根据需要变得简单或复杂。一个简单的工厂可以不依赖于任何其它提供者。一个更复杂的工厂可以自己注入它所需要的其他提供者来计算其结果。对于后一种情况，工厂提供者语法有一对相关机制。</p> <ul><li>工厂函数可以接受（可选）参数。</li> <li>(可选的）<code>inject</code>属性接受一个提供者数组，Nest将在实例化过程中解析并作为参数传递给工厂函数。另外，这些提供者可以被标记为可选。这两个列表应该是相互关联的。Nest将以相同的顺序将inject列表中的实例作为参数传递给工厂函数。下面的例子演示了这一点。</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> connectionFactory <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CONNECTION'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token punctuation">(</span>optionsProvider<span class="token operator">:</span> OptionsProvider<span class="token punctuation">,</span> optionalProvider<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> optionsProvider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  inject<span class="token operator">:</span> <span class="token punctuation">[</span>OptionsProvider<span class="token punctuation">,</span> <span class="token punctuation">{</span> token<span class="token operator">:</span> <span class="token string">'SomeOptionalProvider'</span><span class="token punctuation">,</span> optional<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">//       \_____________/            \__________________/</span>
  <span class="token comment">//        This provider              The provider with this</span>
  <span class="token comment">//        is mandatory.              token can resolves to `undefined`.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>
    connectionFactory<span class="token punctuation">,</span>
    OptionsProvider<span class="token punctuation">,</span>
    <span class="token comment">// { provide: 'SomeOptionalProvider', useValue: 'anything' },</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre></div><h4 id="别名提供者-useexisting"><a href="#别名提供者-useexisting" class="header-anchor">#</a> 别名提供者 (useExisting)</h4> <p>useExisting 语法允许您为现有的提供程序创建别名。这将创建两种访问同一提供者的方法。在下面的示例中，(基于string)令牌 'AliasedLoggerService' 是(基于类的)令牌 LoggerService 的别名。假设我们有两个不同的依赖项，一个用于 'AlilasedLoggerService' ，另一个用于 LoggerService 。如果两个依赖项都用单例作用域指定，它们将解析为同一个实例。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">LoggerService</span> <span class="token punctuation">{</span>
  <span class="token comment">/* implementation details */</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> loggerAliasProvider <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'AliasedLoggerService'</span><span class="token punctuation">,</span>
  useExisting<span class="token operator">:</span> LoggerService<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>LoggerService<span class="token punctuation">,</span> loggerAliasProvider<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h4 id="非服务提供者"><a href="#非服务提供者" class="header-anchor">#</a> 非服务提供者</h4> <p>虽然提供者经常提供服务，但他们并不局限于这种用途。一个提供者可以提供任何价值。例如，提供者可以根据当前环境提供一个配置对象的数组，如下所示。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> configFactory <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CONFIG'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">'development'</span> <span class="token operator">?</span> devConfig <span class="token operator">:</span> prodConfig<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>configFactory<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h4 id="导出自定义提供者"><a href="#导出自定义提供者" class="header-anchor">#</a> 导出自定义提供者</h4> <p>与任何提供程序一样，自定义提供程序的作用域仅限于其声明模块。要使它对其他模块可见，必须导出它。要导出自定义提供程序，我们可以使用其令牌或完整的提供程序对象。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> connectionFactory <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CONNECTION'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token punctuation">(</span>optionsProvider<span class="token operator">:</span> OptionsProvider<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> optionsProvider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  inject<span class="token operator">:</span> <span class="token punctuation">[</span>OptionsProvider<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>connectionFactory<span class="token punctuation">]</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'CONNECTION'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>使用整个对象：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> connectionFactory <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CONNECTION'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token punctuation">(</span>optionsProvider<span class="token operator">:</span> OptionsProvider<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> optionsProvider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  inject<span class="token operator">:</span> <span class="token punctuation">[</span>OptionsProvider<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>connectionFactory<span class="token punctuation">]</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">[</span>connectionFactory<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="_03-异步提供者"><a href="#_03-异步提供者" class="header-anchor">#</a> 03. 异步提供者</h3> <p>有时，应用程序的启动应该被推迟到一个或多个异步任务完成之后。例如，你可能不希望在与数据库建立连接之前开始接受请求。你可以使用异步提供者来实现这一点。</p> <p>其语法是使用 <code>useFactory</code> 语法的 <code>async/await</code>。工厂返回一个承诺，工厂函数可以等待异步任务。在实例化依赖于(注入)这样一个提供程序的任何类之前，Nest将等待承诺的解决。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'ASYNC_CONNECTION'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> connection <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">createConnection</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> connection<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="注入"><a href="#注入" class="header-anchor">#</a> 注入</h4> <p>与任何其他提供程序一样，异步提供程序通过其令牌被注入到其他组件。在上面的示例中，您将使用结构<code>@Inject('ASYNC_CONNECTION')</code>。</p> <h3 id="_03-动态模块"><a href="#_03-动态模块" class="header-anchor">#</a> 03. 动态模块</h3> <p>文档中 &quot;概述 &quot;部分的大多数应用代码示例都使用了常规或静态的模块。
模块定义了像提供者和控制器这样的组件组，它们作为一个整体应用程序的模块化部分被组合在一起。它们为这些组件提供了一个执行环境，或范围。例如，模块中定义的提供者对模块的其他成员是可见的，不需要导出它们。当一个提供者需要在模块外可见时，它首先要从其宿主模块中导出，然后再导入到其消费模块中。</p> <p>定义一个 <code>UsersModule</code> 来提供和导出 UsersService。UsersModule是 UsersService的主机模块。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> UsersService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./users.service'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>UsersService<span class="token punctuation">]</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">[</span>UsersService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">UsersModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>然后，我们定义一个 <code>AuthModule</code>，它导入 <code>UsersModule</code>，使 UsersModule导出的提供程序在 AuthModule中可用:</p> <div class="language- extra-class"><pre class="language-text"><code>import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';

@Module({
    imports: [UserModule],
    providers: [AuthService],
    exports: [AuthService]
})
export class AuthModule {}
</code></pre></div><p>这些构造使我们能够注入 UsersService 例如 AuthService 托管在其中的 AuthModule：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> UsersService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../users/users.service'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> usersService<span class="token operator">:</span> UsersService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">/*
    Implementation that makes use of this.usersService
  */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们将其称为静态模块绑定。Nest在主模块和消费模块中已经声明了连接模块所需的所有信息。让我们来看看这个过程中发生了什么。Nest通过以下方式使 <code>UsersService</code> 在<code>AuthModule</code>中可用:</p> <ol><li><p>实例化 <code>UsersModule</code> ，包括传递导入 <code>UsersModule</code> 本身使用的其他模块，以及传递的任何依赖项(参见自定义提供程序)。</p></li> <li><p>实例化 <code>AuthModule</code> ，并将 <code>UsersModule</code> 导出的提供者提供给 <code>AuthModule</code> 中的组件(就像在 <code>AuthModule</code> 中声明它们一样)。</p></li> <li><p>在 <code>AuthService</code> 中注入 <code>UsersService</code> 实例。</p></li></ol> <h4 id="动态模块实例"><a href="#动态模块实例" class="header-anchor">#</a> 动态模块实例</h4> <p>使用静态模块绑定，消费模块不会影响来自主机模块的提供者的配置方式。为什么这很重要?考虑这样一种情况:我们有一个通用模块，它需要在不同的用例中有不同的行为。这类似于许多系统中的插件概念，在这些系统中，其中一个通用功能在被消费者使用之前需要一些配置。</p> <p><code>Nest</code> 的一个很好的例子是配置模块。 许多应用程序发现使用配置模块来外部化配置详细信息很有用。 这使得在不同部署中动态更改应用程序设置变得容易：例如，开发人员的开发数据库，测试环境的数据库等。通过将配置参数的管理委派给配置模块，应用程序源代码保持独立于配置参数。</p> <p>主要在于配置模块本身，因为它是通用的(类似于 '插件' )，需要由它的消费模块进行定制。这就是动态模块发挥作用的地方。使用动态模块特性，我们可以使配置模块成为动态的，这样消费模块就可以使用 <code>API</code> 来控制配置模块在导入时是如何定制的。</p> <p>换句话说，动态模块提供了一个 <code>API</code> ，用于将一个模块导入到另一个模块中，并在导入模块时定制该模块的属性和行为，而不是使用我们迄今为止看到的静态绑定。</p> <h4 id="配置模块示例"><a href="#配置模块示例" class="header-anchor">#</a> 配置模块示例</h4> <p>在不同项目中使用 <code>ConfigModule</code> 时，选择对应的文件夹</p> <p>动态模块使我们能够将参数传递到要导入的模块中，以便我们可以更改其行为。</p> <p>静态导入 ConfigModule 的示例（即，一种无法影响导入模块行为的方法）</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.controller'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.service'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ConfigModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./config/config.module'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>ConfigModule<span class="token punctuation">]</span><span class="token punctuation">,</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>AppService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>动态模块导入</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.controller'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.service'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ConfigModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./config/config.module'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>ConfigModule<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">{</span> folder<span class="token operator">:</span> <span class="token string">'./config'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>AppService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>上面的动态示例中变化的部分是什么?</p> <ol><li><p><code>ConfigModule</code> 是一个普通类，因此我们可以推断它必须有一个名为 <code>register()</code> 的静态方法。我们知道它是静态的，因为我们是在 <code>ConfigModule</code> 类上调用它，而不是在类的实例上。注意:我们将很快创建的这个方法可以有任意名称，但是按照惯例，我们应该调用它 <code>forRoot()</code> 或 <code>register()</code> 方法。</p></li> <li><p><code>register()</code>方法是由我们定义的，因此我们可以接受任何我们喜欢的参数。在本例中，我们将接受具有适当属性的简单 options 对象，这是典型的情况。</p></li> <li><p>我们可以推断 register() 方法必须返回类似模块的内容，因为它的返回值出现在熟悉的导入列表中，到目前为止，我们已经看到该列表包含了一个模块列表。</p></li></ol> <p>实际上，我们的 <code>register()</code> 方法将返回的是 <code>DynamicModule。</code> 动态模块无非就是在运行时创建的模块，它具有与静态模块相同属性，外加一个称为模块的附加属性。</p> <p>静态模块声明:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>DogsService<span class="token punctuation">]</span><span class="token punctuation">,</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsService<span class="token punctuation">]</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">[</span>CatsService<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>动态模块必须返回具有完全相同接口的对象，外加一个称为module的附加属性。 module属性用作模块的名称，并且应与模块的类名相同，如下例所示。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>对于动态模块，模块选项对象的所有属性都是可选的，模块除外。</p></div> <p>静态 <code>register()</code> 方法呢？ 现在我们可以看到它的工作是返回具有 <code>DynamicModule</code> 接口的对象。 当我们调用它时，我们实际上是在导入列表中提供一个模块，类似于在静态情况下通过列出模块类名的方式。 换句话说，动态模块 API 只是返回一个模块，而不是固定 <code>@Modules</code> 装饰器中的属性，而是通过编程方式指定它们。</p> <p>仍然有一些细节需要详细了解：</p> <ol><li><p>现在我们可以声明 <code>@Module()</code> 装饰器的 <code>imports</code> 属性不仅可以使用一个模块类名(例如，imports: [UsersModule]) ，还可以使用一个返回动态模块的函数(例如，imports: [ConfigModule.register(...)])。</p></li> <li><p>动态模块本身可以导入其他模块。 如果动态模块依赖于其他模块的提供程序，则可以使用可选的 imports 属性导入它们。 同样，这与使用 @Module() 装饰器为静态模块声明元数据的方式完全相似。</p></li></ol> <p>动态 ConfigModule 声明</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> DynamicModule<span class="token punctuation">,</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ConfigService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./config.service'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ConfigModule</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> DynamicModule <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      module<span class="token operator">:</span> ConfigModule<span class="token punctuation">,</span>
      providers<span class="token operator">:</span> <span class="token punctuation">[</span>ConfigService<span class="token punctuation">]</span><span class="token punctuation">,</span>
      exports<span class="token operator">:</span> <span class="token punctuation">[</span>ConfigService<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用 <code>ConfigModule.register(...)</code> 将返回一个 DynamicModule 对象，该对象的属性基本上与我们通过 <code>@Module()</code> 装饰器提供的元数据相同。</p> <h4 id="模块配置"><a href="#模块配置" class="header-anchor">#</a> 模块配置</h4> <p>定制 <code>ConfigModule</code> 行为的解决方案是在静态 <code>register()</code> 方法中向其传递一个 options 对象。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.controller'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.service'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ConfigModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./config/config.module'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>ConfigModule<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">{</span> folder<span class="token operator">:</span> <span class="token string">'./config'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>AppService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>对服务进行一些更改，以便基于 options 对象的属性自定义其行为。
硬编码示例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> dotenv <span class="token keyword">from</span> <span class="token string">'dotenv'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EnvConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./interfaces'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ConfigService</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">readonly</span> envConfig<span class="token operator">:</span> EnvConfig<span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span> folder<span class="token operator">:</span> <span class="token string">'./config'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> filePath <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">||</span> <span class="token string">'development'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.env</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> envFile <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../../'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>folder<span class="token punctuation">,</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>envConfig <span class="token operator">=</span> dotenv<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>envFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>envConfig<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>ConfigModule</code> 提供 <code>ConfigService</code>。而 <code>ConfigService</code> 又依赖于只在运行时提供的 <code>options</code> 对象。因此，在运行时，我们需要首先将 <code>options</code> 对象绑定到 <code>Nest IoC</code>容器，然后让 <code>Nest</code> 将其注入 <code>ConfigService</code> 。</p> <p>将 <code>options</code> 对象绑定到 <code>IoC</code> 容器的问题。我们在静态 <code>register()</code>方法中执行此操作。请记住，我们正在动态地构造一个模块，而模块的一个属性就是它的提供者列表。因此，我们需要做的是将 options 对象定义为提供程序。在下面的代码中，注意 provider 数组:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> DynamicModule<span class="token punctuation">,</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> ConfigService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./config.service'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ConfigModule</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">register</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token operator">:</span> DynamicModule <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      module<span class="token operator">:</span> ConfigModule<span class="token punctuation">,</span>
      providers<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          provide<span class="token operator">:</span> <span class="token string">'CONFIG_OPTIONS'</span><span class="token punctuation">,</span>
          useValue<span class="token operator">:</span> options<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        ConfigService<span class="token punctuation">,</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
      exports<span class="token operator">:</span> <span class="token punctuation">[</span>ConfigService<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，我们可以通过将 <code>CONFIG_OPTIONS</code> 提供者注入 <code>ConfigService</code> 来完成这个过程。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> Inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> dotenv <span class="token keyword">from</span> <span class="token string">'dotenv'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> EnvConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./interfaces'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ConfigService</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">readonly</span> envConfig<span class="token operator">:</span> EnvConfig<span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token string">'CONFIG_OPTIONS'</span><span class="token punctuation">)</span> <span class="token keyword">private</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> filePath <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">||</span> <span class="token string">'development'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.env</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> envFile <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../../'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>folder<span class="token punctuation">,</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>envConfig <span class="token operator">=</span> dotenv<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>envFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>envConfig<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">CONFIG_OPTIONS</span> <span class="token operator">=</span> <span class="token string">'CONFIG_OPTIONS'</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_04-注入作用域"><a href="#_04-注入作用域" class="header-anchor">#</a> 04. 注入作用域</h3> <h4 id="提供者范围"><a href="#提供者范围" class="header-anchor">#</a> 提供者范围</h4> <p>基本上，每个提供者都可以作为一个单例，被请求范围限定，并切换到瞬态模式。请参见下表，以熟悉它们之间的区别。</p> <ul><li>DEFAULT：每个提供者可以跨多个类共享。提供者生命周期严格绑定到应用程序生命周期。一旦应用程序启动，所有提供程序都已实例化。默认情况下使用单例范围。</li> <li>REQUEST：在请求处理完成后，将为每个传入请求和垃圾收集专门创建提供者的新实例</li> <li>TRANSIENT：临时提供者不能在提供者之间共享。每当其他提供者向 Nest 容器请求特定的临时提供者时，该容器将创建一个新的专用实例</li></ul> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>对于大多数用例，建议使用单例范围。请求之间共享提供者可以降低内存消耗，从而提高应用程序的性能(不需要每次实例化类)。</p></div> <h4 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h4> <p>向 @Injectable() 装饰器传递一个选项对象。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> Scope <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> Scope<span class="token punctuation">.</span><span class="token constant">REQUEST</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>在自定义提供者的情况下，必须设置一个额外的范围属性。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token string">'CACHE_MANAGER'</span><span class="token punctuation">,</span>
  useClass<span class="token operator">:</span> CacheManager<span class="token punctuation">,</span>
  scope<span class="token operator">:</span> Scope<span class="token punctuation">.</span><span class="token constant">TRANSIENT</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>网关不应该使用请求范围提供者,因为其必须作为单例提供。每个网关都封装了一个socket并且不能多次实例化。</p> <p>默认使用单例范围,并且不需要声明。如果你想声明一个单例范围的提供者,在scope属性中使用Scope.DEFAULT值。</p></div> <h4 id="控制器范围"><a href="#控制器范围" class="header-anchor">#</a> 控制器范围</h4> <p>控制器也可以有范围，它适用于在该控制器中声明的所有请求方法处理程序。与提供者作用域一样，控制器的作用域声明了它的生命周期。对于请求范围的控制器，为每个入站请求创建一个新实例，并在请求完成处理时进行垃圾收集。
<code>scope</code>使用对象的属性声明控制器范围<code>ControllerOptions:</code></p> <div class="language- extra-class"><pre class="language-text"><code>@Controller({
  path: 'cats',
  scope: Scope.REQUEST,
})
export class CatsController {}
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>网关永远不应该依赖于请求范围的提供者，因为它们充当单例。一个网关封装了一个真正的套接字，不能多次被实例化</p></div> <h4 id="作用域分级"><a href="#作用域分级" class="header-anchor">#</a> 作用域分级</h4> <p><code>REQUEST</code>范围在注入链上冒泡。依赖于请求作用域的控制器，其本身也是请求作用域。</p> <p>想象一下下面的链: <code>CatsController &lt;- CatsService &lt;- CatsRepository</code>.如果<code>CatsService</code>是请求域的（而其他的是默认的单例），那么<code>CatsController</code>将成为请求域的，因为它依赖于注入的服务。而不依赖的CatsRepository将保持单例。</p> <p>瞬时作用的依赖关系并不遵循这种模式。如果一个单例的DogsService注入了一个瞬时的LoggerService提供者，它将收到一个新的实例。然而，DogsService将保持单例，所以在任何地方注入它都不会解析为DogsService的一个新实例。如果这是所希望的行为，DogsService必须明确地被标记为<code>TRANSIENT</code>。</p> <h4 id="请求提供者"><a href="#请求提供者" class="header-anchor">#</a> 请求提供者</h4> <p>在 <code>HTTP</code> 应用程序中(例如使用<code>@nestjs/platform-express</code>或<code>@nestjs/platform-fastify</code>)，当使用请求范围提供者时,可能需要获取原始的请求对象。可以通过注入<code>REQUEST</code>对象来做到这一点。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> Scope<span class="token punctuation">,</span> Inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">REQUEST</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Request <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'express'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> scope<span class="token operator">:</span> Scope<span class="token punctuation">.</span><span class="token constant">REQUEST</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token keyword">private</span> request<span class="token operator">:</span> Request<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h4> <p>使用请求范围的提供者将明显影响应用程序性能。即使 Nest 试图缓存尽可能多的元数据，它仍然必须为每个请求创建类的实例。因此，它将降低平均响应时间和总体基准测试结果。如果提供者不一定需要请求范围，应该坚持使用单例范围。</p> <h3 id="_05-循环依赖"><a href="#_05-循环依赖" class="header-anchor">#</a> 05. 循环依赖</h3> <p>当两个类互相依赖时就会出现循环依赖. 例如，当 A 类需要 B 类，而 B 类也需要 A 类时，就会产生循环依赖。Nest 允许在提供者( provider )和模块( module )之间创建循环依赖关系.</p> <p>建议尽可能避免循环依赖。但是有时候难以避免，<code>Nest</code>提供了两个方法来解决这个问题。即<code>正向引用(forward reference)</code>和<code>模块引用(ModuleRef)</code>来从注入容器中获取一个提供者。</p> <h4 id="正向引用"><a href="#正向引用" class="header-anchor">#</a> 正向引用</h4> <p>正向引用允许 <code>Nest</code> 引用目前尚未被定义的引用。当<code>CatsService</code> 和 <code>CommonService</code> 相互依赖时，关系的双方都需要使用 <code>@Inject()</code> 和 <code>forwardRef()</code> ，否则 <code>Nest</code> 不会实例化它们，因为所有基本元数据都不可用。让我们看看下面的代码片段</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.service.ts</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> CommonService<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> commonService<span class="token operator">:</span> CommonService<span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这只是关系的一方面。现在让我们对 CommonService 做同样的事情</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// common.service.ts</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CommonService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> CatsService<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> catsService<span class="token operator">:</span> CatsService<span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>实例化的顺序是不确定的。确保代码不依赖于首先调用哪个构造函数。具有循环依赖关系依赖于具有<code>Scope.REQUEST</code>的提供程序可能会导致未定义的依赖关系</p></div> <h4 id="可选的模块引用-moduleref-类"><a href="#可选的模块引用-moduleref-类" class="header-anchor">#</a> 可选的模块引用(ModuleRef)类</h4> <p>一个选择是使用forwardRef()来重构你的代码，并使用ModuleRef类来在循环引用关系一侧获取提供者。更多关于ModuleRef类的内容参考这里。</p> <h4 id="模块正向引用"><a href="#模块正向引用" class="header-anchor">#</a> 模块正向引用</h4> <p>为了处理模块( module )之间的循环依赖，必须在模块关联的两个部分上使用相同的 forwardRef()：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// common.module.ts</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> CatsModule<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CommonModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="_06-模块参考"><a href="#_06-模块参考" class="header-anchor">#</a> 06. 模块参考</h3> <p><code>Nest</code>提供了一个<code>ModuleRef</code>类来导航到内部提供者列表，并使用注入令牌作为查找键名来获取一个引用。<code>ModuleRef</code>类也提供了一个动态实例化静态和范围的提供者的方法。<code>ModuleRef</code>可以通过常规方法注入到类中：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.service.tsJS</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ModuleRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> moduleRef<span class="token operator">:</span> ModuleRef<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="获取实例"><a href="#获取实例" class="header-anchor">#</a> 获取实例</h4> <p><code>ModuleRef</code>实例拥有<code>get()</code>方法。该方法获取一个提供者，控制器或者通过注入令牌/类名获取一个在当前模块中可注入对象(例如守卫或拦截器等)。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//cats.service.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ModuleRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token keyword">implements</span> <span class="token class-name">OnModuleInit</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> service<span class="token operator">:</span> Service<span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> moduleRef<span class="token operator">:</span> ModuleRef<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>service <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Service<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>不能通过get()方法获取一个范围的提供者(暂态的或者请求范围的)。</p></div> <p>要从全局上下文获取一个提供者(例如，如果提供者在不同模块中注入)，向get()的第二个参数传递{ strict: false }选项。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Service<span class="token punctuation">,</span> <span class="token punctuation">{</span> strict<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="处理范围提供者"><a href="#处理范围提供者" class="header-anchor">#</a> 处理范围提供者</h4> <p>要动态处理一个范围提供者(瞬态的或请求范围的)，使用<code>resolve()</code>方法并将提供者的注入令牌作为参数提供给方法。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.service.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ModuleRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token keyword">implements</span> <span class="token class-name">OnModuleInit</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> transientService<span class="token operator">:</span> TransientService<span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> moduleRef<span class="token operator">:</span> ModuleRef<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>transientService <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>TransientService<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>resolve()</code>方法从其自身的注入容器树返回一个提供者的唯一实例。每个子树都有一个独一无二的上下文引用。因此如果你调用该方法一次以上并进行引用比较的话，结果是不同的。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ModuleRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token keyword">implements</span> <span class="token class-name">OnModuleInit</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> moduleRef<span class="token operator">:</span> ModuleRef<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> transientServices <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>TransientService<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>TransientService<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>transientServices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> transientServices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要在不同的<code>resolve()</code>调用之间产生一个单例，并保证他们共享同样生成的<code>DI</code>容器子树，向<code>resolve()</code>方法传递一个上下文引用，使用<code>ContextIdFactory</code>类来生成上下文引用。该类提供了一个<code>create()</code>方法，返回一个合适的独一无二的引用。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>ContextIdFactory<span class="token punctuation">,</span> ModuleRef<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token keyword">implements</span> <span class="token class-name">OnModuleInit</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> moduleRef<span class="token operator">:</span> ModuleRef<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> contextId <span class="token operator">=</span> ContextIdFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> transientServices <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>TransientService<span class="token punctuation">,</span> contextId<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>TransientService<span class="token punctuation">,</span> contextId<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>transientServices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> transientServices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="注册request提供者"><a href="#注册request提供者" class="header-anchor">#</a> 注册REQUEST提供者</h4> <p>手动生成的上下文标识符（用ContextIdFactory.create()）代表DI子树，其中REQUEST提供者是未定义的，因为它们没有被Nest依赖注入系统实例化和管理。</p> <p>要为手动创建的<code>DI</code>子树注册一个自定义<code>REQUEST</code>对象，使用如下所示方法。</p> <div class="language- extra-class"><pre class="language-text"><code>const contextId = ContextIdFactory.create();
this.moduleRef.registerRequestByContextId(/* YOUR_REQUEST_OBJECT */, contextId);
</code></pre></div><h4 id="获取当前子树"><a href="#获取当前子树" class="header-anchor">#</a> 获取当前子树</h4> <p>有时，也需要在请求上下文中获取一个请求范围提供者的实例。例如，<code>CatsService</code>是请求范围的，要获取的<code>CatsRepository</code>实例也被标识为请求范围。要分享同一个注入容器子树，你需要获取当前上下文引用而不是生成一个新的(像前面的<code>ContextIdFactory.create()</code>函数)。使用<code>@Inject()</code>来获取当前的请求对象。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.service.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token keyword">private</span> request<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用<code>ContextIdFactory</code>类的<code>getByRequest()</code>方法来基于请求对象创建一个上下文id 并传递<code>resolve()</code>调用:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> contextId <span class="token operator">=</span> ContextIdFactory<span class="token punctuation">.</span><span class="token function">getByRequest</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> catsRepository <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>CatsRepository<span class="token punctuation">,</span> contextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="动态实例化自定义类"><a href="#动态实例化自定义类" class="header-anchor">#</a> 动态实例化自定义类</h4> <p>要动态实例化一个之前未注册的类作为提供者，使用模块引用的create()方法。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.service.ts</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token keyword">implements</span> <span class="token class-name">OnModuleInit</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> catsFactory<span class="token operator">:</span> CatsFactory<span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> moduleRef<span class="token operator">:</span> ModuleRef<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>catsFactory <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>moduleRef<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>CatsFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_07-懒加载模块"><a href="#_07-懒加载模块" class="header-anchor">#</a> 07. 懒加载模块</h3> <p>默认情况下，模块是急切加载的，这意味着一旦应用程序加载，所有模块也会加载，无论它们是否立即需要。虽然这对大多数应用程序来说都很好，但它可能成为在无服务器环境中运行的应用程序/工作人员的瓶颈，其中启动延迟（“冷启动”）至关重要。</p> <p>延迟加载可以通过仅加载特定无服务器函数调用所需的模块来帮助减少引导时间。此外，您还可以在无服务器功能“热启”后异步加载其他模块，以进一步加快后续调用的引导时间（延迟模块注册）。</p> <p>为了按需加载模块，Nest 提供了<code>LazyModuleLoader</code>可以以正常方式注入到类中的类：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LazyModuleLoader <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token comment">// cats.service.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsService</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> lazyModuleLoader<span class="token operator">:</span> LazyModuleLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者，可以从应用程序引导文件 (main.ts )中获取对提供程序的懒加载<code>LazyModuleLoader</code>引用，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// &quot;app&quot; represents a Nest application instance</span>
<span class="token keyword">const</span> lazyModuleLoader <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>LazyModuleLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>有了上述，现在可以使用以下结构加载任何模块：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> LazyModule <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./lazy.module'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazyModuleLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> LazyModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p><code>延迟加载</code>模块在第一次方法调用时被缓存。<code>LazyModuleLoader#load</code>这意味着，每次连续的加载尝试<code>LazyModule</code>都会非常快，并且会返回一个缓存的实例，而不是再次加载模块。</p></div> <div class="language- extra-class"><pre class="language-text"><code>Load &quot;LazyModule&quot; attempt: 1
time: 2.379ms
Load &quot;LazyModule&quot; attempt: 2
time: 0.294ms
Load &quot;LazyModule&quot; attempt: 3
time: 0.303ms

</code></pre></div><p>此外，<code>延迟加载</code>模块与那些在应用程序引导程序上急切加载的模块以及在应用程序中注册的任何其他延迟模块共享相同的模块图。</p> <p>当<code>lazy.module.ts</code>是是一个<code>TypeScript</code>文件 那可以导出为常规 Nest 模块（无需额外更改）。</p> <p>该<code>LazyModuleLoader#load</code>方法返回模块引用(of <code>LazyModule</code>)，它允许您导航提供者的内部列表并使用其注入令牌作为查找键获取对任何提供者的引用。</p> <p>例如，假设我们有LazyModule以下定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>LazyService<span class="token punctuation">]</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">[</span>LazyService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">LazyModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>延迟加载的模块不能注册为全局模块，因为它根本没有意义（因为它们是延迟注册的，当所有静态注册的模块都已经实例化时按需注册）。同样，注册的全局增强器（守卫/拦截器/等）也无法正常工作。</p></div> <p>有了这个，我们可以获得对<code>LazyService</code>提供者的引用，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> LazyModule <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./lazy.module'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazyModuleLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> LazyModule<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> LazyService <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./lazy.service'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> lazyService <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>LazyService<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>如果使用Webpack，请确保更新tsconfig.json文件 - 设置compilerOptions.module并&quot;esnext&quot;添加compilerOptions.moduleResolution属性&quot;node&quot;作为值：</p> <p>{
&quot;compilerOptions&quot;: {
&quot;module&quot;: &quot;esnext&quot;,
&quot;moduleResolution&quot;: &quot;node&quot;,
}
}</p></div> <h4 id="延迟加载控制器、网关和解析器"><a href="#延迟加载控制器、网关和解析器" class="header-anchor">#</a> 延迟加载控制器、网关和解析器</h4> <p>由于 <code>Nest</code> 中的控制器（或 <code>GraphQL</code> 应用程序中的解析器）表示一组路由/路径/主题（或查询/突变），因此不能使用<code>LazyModuleLoader</code>该类延迟加载它们。</p> <h3 id="_08-应用上下文"><a href="#_08-应用上下文" class="header-anchor">#</a> 08. 应用上下文</h3> <p>Nest提供了一些应用类来简化在不同应用上下文之间编写应用(例如Nest HTTP应用，微服务和WebSockets应用)。这些应用可以用于创建通用的守卫，过滤器和拦截器，可以工作在控制器，方法和应用上下文中。</p> <h4 id="argumentshost类"><a href="#argumentshost类" class="header-anchor">#</a> ArgumentsHost类</h4> <p><code>ArgumentsHost</code>类提供了获取传递给处理程序的参数。它允许选择合适的上下文(例如HTTP，RPC(微服务)或者Websockets)来从框架中获取参数。框架提供了<code>ArgumentsHost</code>的实例，作为<code>host</code>参数提供给需要获取的地方。例如，在异常过滤器中传入<code>ArgumentsHost</code>参数来调用<code>catch()</code>方法。</p> <p><code>ArgumentsHost</code>简单地抽象为处理程序参数。例如，在HTTP应用中(使用@nestjs/platform-express时),host对象封装了Express的[request, response, next]数组,reuest是一个request对象，response是一个response对象，next是控制应用的请求响应循环的函数。此外，在GraphQL应用中，host包含[root, args, context, info]数组。</p> <h4 id="当前应用上下文"><a href="#当前应用上下文" class="header-anchor">#</a> 当前应用上下文</h4> <p>当构建通用的守卫，过滤器和拦截器时，意味着要跨应用上下文运行，我们需要一种方法来确定我们的方法当前正在运行的应用程序类型。可以使用<code>ArgumentsHost</code>的<code>getType()</code>方法。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> GqlContextType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'http'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do something that is only important in the context of regular HTTP requests (REST)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'rpc'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do something that is only important in the context of Microservice requests</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">getType</span><span class="token generic class-name"><span class="token operator">&lt;</span>GqlContextType<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'graphql'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do something that is only important in the context of GraphQL requests</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="host处理程序参数"><a href="#host处理程序参数" class="header-anchor">#</a> Host处理程序参数</h4> <p>要获取传递给处理程序的参数数组，使用<code>host</code>对象的<code>getArgs()</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>const [req, res, next] = host.getArgs();
</code></pre></div><p>可以使用<code>getArgByIndex()</code>根据索引获取指定参数:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> request <span class="token operator">=</span> host<span class="token punctuation">.</span><span class="token function">getArgByIndex</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> response <span class="token operator">=</span> host<span class="token punctuation">.</span><span class="token function">getArgByIndex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这些例子中我们通过索引来获取请求响应对象，这并不推荐，因为它将应用和特定上下文耦合。为了使代码鲁棒性更好，更可复用，可以在程序中使用host对象的应用方法来切换合适的应用上下文，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * Switch context to RPC.
 */</span>
<span class="token function">switchToRpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> RpcArgumentsHost<span class="token punctuation">;</span>
<span class="token comment">/**
 * Switch context to HTTP.
 */</span>
<span class="token function">switchToHttp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> HttpArgumentsHost<span class="token punctuation">;</span>
<span class="token comment">/**
 * Switch context to WebSockets.
 */</span>
<span class="token function">switchToWs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> WsArgumentsHost<span class="token punctuation">;</span>
</code></pre></div><p>使用 <code>switchToHttp()</code> 方法重写前面的例子，<code>host.switchToHttp()</code>帮助方法调用一个<code>HTTP</code>应用的<code>HttpArgumentsHost</code>对象. <code>HttpArgumentsHost</code>对象有两个有用的方法，我们可以用来提取期望的对象。我们也可以使用Express类型的断言来返回原生的Express类型对象：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> ctx <span class="token operator">=</span> host<span class="token punctuation">.</span><span class="token function">switchToHttp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> request <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">getRequest</span><span class="token generic class-name"><span class="token operator">&lt;</span>Request<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> response <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">getResponse</span><span class="token generic class-name"><span class="token operator">&lt;</span>Response<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>类似地，WsArgumentsHost和RpcArgumentsHost有返回微服务和WebSockets上下文的方法，以下是WsArgumentsHost的方法:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">WsArgumentsHost</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * Returns the data object.
   */</span>
  <span class="token generic-function"><span class="token function">getData</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token comment">/**
   * Returns the client object.
   */</span>
  <span class="token generic-function"><span class="token function">getClient</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>RpcArgumentsHost方法：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">RpcArgumentsHost</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * Returns the data object.
   */</span>
  <span class="token generic-function"><span class="token function">getData</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

  <span class="token comment">/**
   * Returns the context object.
   */</span>
  <span class="token generic-function"><span class="token function">getContext</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="执行上下文类"><a href="#执行上下文类" class="header-anchor">#</a> 执行上下文类</h4> <p><code>ExecutionContext</code>扩展了<code>ArgumentsHost</code>,提供有关当前执行过程的其他详细信息。和<code>ArgumentsHost</code>类似,<code>Nest</code>在需要的时候提供了一个<code>ExecutionContext</code>的实例， 例如守卫的<code>canActivate()</code>方法和拦截器的<code>intercept()</code>方法，它提供以下方法:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutionContext</span> <span class="token keyword">extends</span> <span class="token class-name">ArgumentsHost</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * Returns the type of the controller class which the current handler belongs to.
   */</span>
  <span class="token generic-function"><span class="token function">getClass</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Type<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token comment">/**
   * Returns a reference to the handler (method) that will be invoked next in the
   * request pipeline.
   */</span>
  <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>getHandler()</code>方法返回要调用的处理程序的引用。
<code>getClass()</code>方法返回一个特定处理程序所属的控制器类。例如，一个<code>HTTP</code>上下文，如果当前处理的是一个<code>POST</code>请求，在<code>CatsController</code>中绑定<code>create()</code>方法。<code>getHandler()</code>返回<code>create()</code>方法和<code>getClass()</code>方法所在的<code>CatsController</code>类的引用(不是实例)。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> methodKey <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// &quot;create&quot;</span>
<span class="token keyword">const</span> className <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// &quot;CatsController&quot;</span>
</code></pre></div><p>访问对当前类和处理程序方法的引用的能力提供了极大的灵活性。最重要的是，它让我们有机会通过<code>@SetMetadata()</code>装饰器从守卫或拦截器中访问元数据集。我们将在下面介绍这个用例。</p> <h4 id="反射和元数据"><a href="#反射和元数据" class="header-anchor">#</a> 反射和元数据</h4> <p><code>Nest</code>提供了通过<code>@SetMetadata()</code>装饰器将自定义元数据附加在路径处理程序的能力。我们可以在类中获取这些元数据来执行特定决策。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>SetMetadata<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token comment">// cats.controller.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">SetMetadata</span></span><span class="token punctuation">(</span><span class="token string">'roles'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'admin'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>基于上述结构，我们将roles元数据(roles是一个元数据，并且['admin'] 是对应的值)关联到create()方法。在这种情况下，不推荐直接在路径中使用@SetMetadata()，而是应该如下创建自己的装饰器：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">//roles.decorator.ts</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> SetMetadata <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Roles</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>roles<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">SetMetadata</span><span class="token punctuation">(</span><span class="token string">'roles'</span><span class="token punctuation">,</span> roles<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种方法更干净、更易读，并且是强类型的。
现在可以使用自定义的@Roles()装饰器，并将其应用在create()方法中。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.controller.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Roles</span></span><span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要访问roles路径 (自定义元数据),我们将使用<code>Reflector</code>辅助类，它由框架提供，开箱即用，从@nestjs/core包导入。Reflector可以通过常规方式注入到类:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Reflector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token comment">// roles.guard.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">RolesGuard</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> reflector<span class="token operator">:</span> Reflector<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用<code>get()</code>方法读取处理程序的元数据。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> roles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'roles'</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>Reflector#get</code>方法允许通过传递两个参数简单获取元数据：一个元数据key和一个context(装饰器对象)来获取元数据。
在本例中，指定的key是roles。context 由context.getHandler()提供,用于从当前路径处理程序中获取元数据，getHandler()给了我们一个到路径处理函数的引用。</p> <p>我们也可以组织我们的控制器，来从控制器层获取元数据，以在控制器所有路径中应用。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.controller.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Roles</span></span><span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>在本例中，要获取控制器元数据，将<code>context.getClass()</code>作为第二个参数(将控制器类作为上下文提供以获取元数据)来替代<code>context.getHandler()</code>:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// roles.guard.ts</span>

<span class="token keyword">const</span> roles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'roles'</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>要具备在多层提供元数据的能力，需要从多个上下文获取与合并元数据。Reflector类提供两个应用方法来帮助实现该功能。这些方法同时获取控制器和方法元数据，并通过不同方法来合并他们。</p> <p>考虑以下场景，在两个水平应用roles都提供了元数据：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.controller.ts</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Roles</span></span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Controller</span></span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Roles</span></span><span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果你想将user指定为默认角色，并且出于特定目的有选择地进行覆盖，可以使用<code>getAllAndOverride()</code>方法。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> roles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">getAllAndOverride</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'roles'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  context<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  context<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用该代码编写守卫，在上下文中应用create()方法，采用上述元数据，将生成包含 ['admin']的roles。</p> <p>要获取与合并元数据(该方法合并数组和对象)，使用getAllAndMerge()方法：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> roles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">getAllAndMerge</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">'roles'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
  context<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  context<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这会生成包含<code>['user', 'admin']</code>的<code>roles</code>。</p> <p>对于这两种合并方法，传输元数据作为第一个参数，数组或者元数据对象上下文(例如，调用getHandler()和/或getClass())作为第二个参数。</p> <h3 id="_09-声明周期事件"><a href="#_09-声明周期事件" class="header-anchor">#</a> 09. 声明周期事件</h3> <p>所有应用程序元素都有一个由 Nest 管理的生命周期。Nest 提供了生命周期钩子，提供了对关键生命时刻的可见性，以及在关键时刻发生时采取行动(在你的<code>module</code>，<code>injectable</code>或者<code>controller</code>中注册代码)的能力。</p> <h4 id="生命周期序列"><a href="#生命周期序列" class="header-anchor">#</a> 生命周期序列</h4> <p>下图描述了关键应用生命周期事件序列，从应用引导之时到node应用退出。我们可以把整个生命周期划分为三个阶段：初始化，运行和终止。使用生命周期，你可以合理计划模块和服务的初始化，管理活动链接，并且在应用程序收到终止指令时优雅地退出。
<img src="/images/nest/lifecycle-events.png" alt=""></p> <h4 id="生命周期事件"><a href="#生命周期事件" class="header-anchor">#</a> 生命周期事件</h4> <p>生命周期事件在<code>应用初始化</code>与<code>终止</code>时发生。Nest在<code>modules</code>，<code>injectables</code>和<code>controllers</code>的以下每个生命周期事件(首先要使能shutdown钩子，如下描述)中调用注册钩子方法。和上图所示的一样，Nest也调用合适的底层方法来监听连接，以及终止监听连接。</p> <p>在下述表格中，onModuleDestroy, beforeApplicationShutdown和 onApplicationShutdown仅仅在显式调用app.close()或者应用收到特定系统信号(例如 SIGTERM)并且在初始化时(参见下表的应用shutdown部分)正确调用了enableShutdownHooks方法后被触发。</p> <table><thead><tr><th>生命周期钩子方法</th> <th>生命周期时间触发钩子方法调用</th></tr></thead> <tbody><tr><td>OnModuleInit()</td> <td>初始化主模块依赖处理后调用一次</td></tr> <tr><td>OnApplicationBootstrap()</td> <td>在应用程序完全启动并监听连接后调用一次</td></tr> <tr><td>OnModuleDestroy()</td> <td>收到终止信号(例如SIGTERM)后调用</td></tr> <tr><td>beforeApplicationShutdown()</td> <td>在onModuleDestroy()完成(Promise被resolved或者rejected)；一旦完成，将关闭所有连接(调用app.close() 方法).</td></tr> <tr><td>OnApplicationShutdown()</td> <td>连接关闭处理时调用(app.close())</td></tr></tbody></table> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>上述列出的生命周期钩子没有被请求范围类触发。请求范围类并没有和生命周期以及不可预测的寿命绑定。他们为每个请求单独创建，并在响应发送后通过垃圾清理系统自动清理。</p></div> <h4 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h4> <p>所有应用周期的钩子都有接口表示，接口在技术上是可选的，因为它们在 TypeScript 编译之后就不存在了。尽管如此，为了从强类型和编辑器工具中获益，使用它们是一个很好的实践。要注册生命周期挂钩，请实现适当的接口。例如，要注册一个方法在特定类(例如，控制器，提供者或者模块)初始化时调用，使用OnModuleInit接口，提供onModuleInit()方法，如下：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> OnModuleInit <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">UsersService</span> <span class="token keyword">implements</span> <span class="token class-name">OnModuleInit</span> <span class="token punctuation">{</span>
  <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The module has been initialized.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>异步初始化</li></ul> <p>此外，<code>OnModuleInit</code> 和 <code>OnApplicationBootstrap</code> 钩子都允许延迟应用程序初始化过程(返回一个Promise或在方法主体中将方法标记为async和await异步方法)。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">async</span> <span class="token function">onModuleInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="应用程序关闭"><a href="#应用程序关闭" class="header-anchor">#</a> 应用程序关闭</h4> <p><code>onModuleDestroy()</code>, <code>beforeApplicationShutdown()</code>和 <code>onApplicationShutdown()</code>钩子程序响应系统终止信号(当应用程序通过显示调用app.close()或者收到SIGTERM系统信号时)，以优雅地关闭 Nest 应用程序。这一功能通常用于 Kubernetes 、Heroku 或类似的服务。</p> <p>系统关闭钩子消耗系统资源，因此默认是禁用的。要使用此钩子，必须通过<code>enableShutdownHooks()</code>激活侦听器。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> NestFactory <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.module'</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">await</span> NestFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>AppModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Starts listening to shutdown hooks</span>
  app<span class="token punctuation">.</span><span class="token function">enableShutdownHooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p><code>enableShutdownHooks</code>开始监听时消耗内存。如果要在一个单独Node线程中运行多个Nest应用(例如，使用多个Jest运行测试)，Node会抱怨监听者太多。出于这个原因，enableShutdownHooks默认未启用。要在单个Node进程中运行多个实例时尤其要注意这一点。</p></div> <p>如果应用程序接收到一个终止信号，它将会依次调用注册的<code>onModuleDestroy()</code>,<code>beforeApplicationShutdown()</code>和<code>onApplicationShutdown()</code>方法，将响应信号作为第一个参数。如果一个注册函数等待异步调用(作为promise)，那么在 promise 被解析或拒绝之前，它不会关闭 Nest 应用程序。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">UsersService</span> <span class="token keyword">implements</span> <span class="token class-name">OnApplicationShutdown</span> <span class="token punctuation">{</span>
  <span class="token function">onApplicationShutdown</span><span class="token punctuation">(</span>signal<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>signal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// e.g. &quot;SIGINT&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>调用app.close()不会终止Node进程，只会触发onModuleDestroy()和onApplicationShutdown()钩子，所以如果有一些间隔，长时间运行的后台任务等，该进程不会自动终止。</p></div> <h3 id="_10-测试"><a href="#_10-测试" class="header-anchor">#</a> 10. 测试</h3> <p>自动化测试被认为是任何成熟的软件开发工作的一个重要组成部分。自动化使得在开发过程中快速、轻松地重复独立测试或者单元测试变得容易。这有助于确保版本满足质量和性能目标。自动化有助于提高覆盖率，并为开发人员提供一个更快的反馈回路。自动化既能提高单个开发人员的生产力，又能确保测试在关键的开发生命周期节点上运行，如源代码控制签入、功能集成和版本发布。</p> <p>这种测试通常跨越多种类型，包括单元测试、端到端（e2e）测试、集成测试等等。虽然好处是毋庸置疑的，但设置它们可能会很繁琐。Nest努力促进开发的最佳实践，包括有效的测试，所以它包括以下功能，以帮助开发人员和团队建立和自动化测试。</p> <ul><li>自动为组件提供默认单元测试，为应用程序提供e2e测试。</li> <li>提供默认的工具（如测试运行器，建立一个孤立的模块/应用加载器）。</li> <li>提供<code>Jest</code>和<code>Supertest</code>开箱即用的集成，兼容其他测试工具。</li> <li>在测试环境中保证<code>Nest</code>依赖性注入系统，以便轻松模拟组件。</li></ul> <p>如前所述，你可以使用任何你喜欢的测试框架，因为Nest并不强制要求任何特定的工具。只需替换需要的元素（如测试运行器），你仍然可以享受Nest现成的测试设施的好处。</p> <h4 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h4> <p>开始工作，首先要安装所需的软件包。</p> <div class="language- extra-class"><pre class="language-text"><code>npm i --save-dev @nestjs/testing
</code></pre></div><h4 id="单元测试"><a href="#单元测试" class="header-anchor">#</a> 单元测试：</h4> <p>在下面的例子中，我们测试了两个类。<code>CatsController</code>和<code>CatsService</code>。如前所述，Jest被提供为默认的测试框架。它作为一个测试运行器，还提供了断言函数和测试双重工具。在下面的基本测试中，我们手动实例化这些类，并保证控制器和服务满足他们的API接口。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.controller.spec.tsJS</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats.controller'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats.service'</span><span class="token punctuation">;</span>

<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'CatsController'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> catsController<span class="token operator">:</span> CatsController<span class="token punctuation">;</span>
  <span class="token keyword">let</span> catsService<span class="token operator">:</span> CatsService<span class="token punctuation">;</span>

  <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    catsService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatsService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    catsController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatsController</span><span class="token punctuation">(</span>catsService<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'findAll'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should return an array of cats'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      jest<span class="token punctuation">.</span><span class="token function">spyOn</span><span class="token punctuation">(</span>catsService<span class="token punctuation">,</span> <span class="token string">'findAll'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mockImplementation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> catsController<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="测试工具"><a href="#测试工具" class="header-anchor">#</a> 测试工具</h4> <p>@nestjs/testing包提供了一组实用工具，使测试过程更加健全。让我们使用内置的测试类重写前面的例子。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.controller.spec.ts</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Test <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/testing'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats.controller'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cats.service'</span><span class="token punctuation">;</span>

<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'CatsController'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> catsController<span class="token operator">:</span> CatsController<span class="token punctuation">;</span>
  <span class="token keyword">let</span> catsService<span class="token operator">:</span> CatsService<span class="token punctuation">;</span>

  <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> Test<span class="token punctuation">.</span><span class="token function">createTestingModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        controllers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsController<span class="token punctuation">]</span><span class="token punctuation">,</span>
        providers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsService<span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    catsService <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>CatsService<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>CatsService<span class="token punctuation">)</span><span class="token punctuation">;</span>
    catsController <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>CatsController<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>CatsController<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'findAll'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should return an array of cats'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      jest<span class="token punctuation">.</span><span class="token function">spyOn</span><span class="token punctuation">(</span>catsService<span class="token punctuation">,</span> <span class="token string">'findAll'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mockImplementation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token keyword">await</span> catsController<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>Test</code>类提供应用上下文以模拟整个Nest运行时，但提供了使管理类实例变得容易的钩子，包括<code>模拟</code>和<code>覆盖</code>，这一点很有用。 Test 类有一个 <code>createTestingModule()</code> 方法，该方法将模块的元数据（与在 @Module() 装饰器中传递的对象相同的对象）作为参数。这个方法创建了一个 <code>TestingModule</code> 实例，该实例提供了一些方法，但是当涉及到单元测试时，这些方法中只有 <code>compile()</code> 是有用的。这个方法初始化一个模块和它的依赖(和传统应用中从main.ts文件使用NestFactory.create()方法类似)，并返回一个准备用于测试的模块。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p><code>compile()</code>方法是异步的，因此必须等待执行完成。一旦模块编译完成，可以使用<code>get()</code>方法获取任何声明的静态实例(控制器和提供者)。</p></div> <p><code>TestingModule</code>继承自module reference类，因此具备动态处理提供者的能力(暂态的或者请求范围的)，可以使用<code>resolve()</code>方法(<code>get()</code>方法只能检索获取静态实例).</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> Test<span class="token punctuation">.</span><span class="token function">createTestingModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsController<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsService<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

catsService <span class="token operator">=</span> <span class="token keyword">await</span> moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>CatsService<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>resolve()</code>方法从其自身的注入容器子树返回一个提供者的单例，每个子树都有一个独有的上下文引用。因此，如果你调用这个方法多次，可以看到它们是不同的。</p> <h4 id="自动模拟"><a href="#自动模拟" class="header-anchor">#</a> 自动模拟</h4> <p><code>Nest</code> 还允许定义一个模拟工厂以应用于所有缺少的依赖项。这对于在一个类中有大量依赖项并且模拟所有依赖项需要很长时间和大量设置的情况很有用。要使用此功能，<code>createTestingModule()</code>需要将方法与<code>useMocker()</code>方法链接起来，为依赖模拟传递一个工厂。这个工厂可以接受一个可选的令牌，它是一个实例令牌，任何对 Nest 提供者有效的令牌，并返回一个模拟实现。</p> <p>下面是创建通用模拟程序使用jest-mock和特定模拟程序CatsService使用的示例jest.fn()。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> moduleMocker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModuleMocker</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'CatsController'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> controller<span class="token operator">:</span> CatsController<span class="token punctuation">;</span>

  <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> Test<span class="token punctuation">.</span><span class="token function">createTestingModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      controllers<span class="token operator">:</span> <span class="token punctuation">[</span>CatsController<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">useMocker</span><span class="token punctuation">(</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">===</span> CatsService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> findAll<span class="token operator">:</span> jest<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mockResolvedValue</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> token <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> mockMetadata <span class="token operator">=</span> moduleMocker<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token keyword">as</span> MockFunctionMetadata<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> Mock <span class="token operator">=</span> moduleMocker<span class="token punctuation">.</span><span class="token function">generateFromMetadata</span><span class="token punctuation">(</span>mockMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    controller <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CatsController<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h4 id="端到端测试"><a href="#端到端测试" class="header-anchor">#</a> 端到端测试</h4> <p>与关注单个模块和类的单元测试不同，端到端（e2e）测试涵盖了类和模块在更高层次上的交互--和生产环境下终端用户类似。随着应用程序的增长，手动测试每个API端点的端到端行为变得困难。自动化的端到端测试帮助我们确保系统的整体行为是正确的，并符合项目要求。为了进行e2e测试，我们使用类似于刚才单元测试中的配置。此外，Nest使我们能够轻松地使用Supertest库来模拟HTTP请求。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// cats.e2e-spec.ts</span>

<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> request <span class="token keyword">from</span> <span class="token string">'supertest'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Test <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/testing'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../src/cats/cats.module'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> CatsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../src/cats/cats.service'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> INestApplication <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'Cats'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> app<span class="token operator">:</span> INestApplication<span class="token punctuation">;</span>
  <span class="token keyword">let</span> catsService <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">findAll</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">beforeAll</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> Test<span class="token punctuation">.</span><span class="token function">createTestingModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      imports<span class="token operator">:</span> <span class="token punctuation">[</span>CatsModule<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">overrideProvider</span><span class="token punctuation">(</span>CatsService<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">useValue</span><span class="token punctuation">(</span>catsService<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    app <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token function">createNestApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">it</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/GET cats</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span><span class="token function">getHttpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/cats'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        data<span class="token operator">:</span> catsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">afterAll</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果使用Fasify作为HTTP服务器，在配置上有所不同，其有一些内置功能：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> app<span class="token operator">:</span> NestFastifyApplication<span class="token punctuation">;</span>

<span class="token function">beforeAll</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  app <span class="token operator">=</span> moduleRef<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">createNestApplication</span><span class="token generic class-name"><span class="token operator">&lt;</span>NestFastifyApplication<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">FastifyAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">getHttpAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">it</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/GET cats</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> app
    <span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      method<span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>
      url<span class="token operator">:</span> <span class="token string">'/cats'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>statusCode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token comment">/* expectedPayload */</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在这个例子中，我们使用了之前描述的概念，在之前使用的<code>compile()</code>外，我们使用<code>createNestApplication()</code>方法来实例化一个Nest运行环境。我们在app变量中储存了一个app引用以便模拟HTTP请求。</p> <p>使用<code>Supertest</code>的<code>request()</code>方法来模拟HTTP请求。我们希望这些HTTP请求访问运行的Nest应用，因此向request()传递一个Nest底层的HTTP监听者(可能由Express平台提供)，以此构建请求(app.getHttpServer())，调用request()交给我们一个包装的HTTP服务器以连接Nest应用，它暴露了模拟真实HTTP请求的方法。例如，使用request(...).get('/cats')将初始化一个和真实的从网络来的get '/cats'相同的HTTP请求。</p> <p>在这个例子中，我们也提供了一个可选的 <code>CatsService</code>应用，它返回一个硬编码值供我们测试。使用<code>overrideProvider()</code>来进行覆盖替换。类似地，Nest也提供了覆盖守卫，拦截器，过滤器和管道的方法：<code>overrideGuard()</code>, <code>overrideInterceptor()</code>, <code>overrideFilter()</code>, <code>overridePipe()</code>。</p> <p>每个覆盖方法返回包括3个不同的在自定义提供者中描述的方法镜像：</p> <ul><li>useClass: 提供一个类来覆盖对象(提供者，守卫等)。</li> <li>useValue: 提供一个实例来覆盖对象。</li> <li>useFactory: 提供一个方法来返回覆盖对象的实例。</li></ul> <p>每个覆盖方法都返回<code>TestingModule</code>实例，可以通过链式写法与其他方法连接。可以在结尾使用compile()方法以使Nest实例化和初始化模块。</p> <p>此外，有时你可能想提供一个自定义的日志，例如，当测试运行时（例如，在CI服务器上）。使用setLogger()方法并传递一个满足LoggerService接口的对象来指示TestModuleBuilder如何在测试期间记录（默认情况下，只有 &quot;错误 &quot;日志会被记录到控制台）。</p> <p>该编译模块有几个有用的方法，如下表所述:</p> <ul><li>createNestInstance()	基于给定模块创建一个Nest实例（返回INestApplication）,请注意，必须使用init()方法手动初始化应用程序</li> <li>createNestMicroservice()	基于给定模块创建Nest微服务实例（返回INestMicroservice）</li> <li>get()	从module reference类继承，检索应用程序上下文中可用的控制器或提供程序（包括警卫，过滤器等）的实例</li> <li>resolve()	从module reference类继承，检索应用程序上下文中控制器或提供者动态创建的范围实例（包括警卫，过滤器等）的实例</li> <li>select()	浏览模块树，从所选模块中提取特定实例（与get()方法中严格模式{strict：true}一起使用)</li></ul> <h4 id="覆盖全局注册的强化程序"><a href="#覆盖全局注册的强化程序" class="header-anchor">#</a> 覆盖全局注册的强化程序</h4> <p>如果有一个全局注册的守卫 (或者管道，拦截器或过滤器),可能需要更多的步骤来覆盖他们。 将原始的注册做如下修改:</p> <div class="language-ts extra-class"><pre class="language-ts"><code>providers<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    provide<span class="token operator">:</span> <span class="token constant">APP_GUARD</span><span class="token punctuation">,</span>
    useClass<span class="token operator">:</span> JwtAuthGuard<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div><p>这样通过APP_*把守卫注册成了&quot;multi&quot;-provider。要在这里替换 JwtAuthGuard，应该在槽中使用现有提供者。</p> <p>将useClass修改为useExisting来引用注册提供者，而不是在令牌之后使用Nest实例化。</p> <div class="language-ts extra-class"><pre class="language-ts"><code>providers<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    provide<span class="token operator">:</span> <span class="token constant">APP_GUARD</span><span class="token punctuation">,</span>
    useExisting<span class="token operator">:</span> JwtAuthGuard<span class="token punctuation">,</span>
    <span class="token comment">// notice the use of 'useExisting' instead of 'useClass'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  JwtAuthGuard<span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div><p>现在<code>JwtAuthGuard</code>在Nest可以作为一个常规的提供者，也可以在创建<code>TestingModule</code>时被覆盖 :</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> moduleRef <span class="token operator">=</span> <span class="token keyword">await</span> Test<span class="token punctuation">.</span><span class="token function">createTestingModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>AppModule<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">overrideProvider</span><span class="token punctuation">(</span>JwtAuthGuard<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">useClass</span><span class="token punctuation">(</span>MockAuthGuard<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样测试就会在每个请求中使用<code>MockAuthGuard</code>。</p> <h4 id="测试请求范围实例"><a href="#测试请求范围实例" class="header-anchor">#</a> 测试请求范围实例</h4> <p>请求范围提供者针对每个请求创建。其实例在请求处理完成后由垃圾回收机制销毁。这产生了一个问题，因为我们无法针对一个测试请求获取其注入依赖子树。</p> <p>resolve()方法可以用来获取一个动态实例化的类。因此，我们可以传递一个独特的上下文引用来控制注入容器子树的声明周期。如何来在测试上下文中暴露它呢？</p> <p>[策略]是生成一个上下文向前引用并且强迫Nest使用这个特殊ID来为所有输入请求创建子树。这样我们就可以获取为测试请求创建的实例。</p> <p>将<code>jest.spyOn()</code>应用于<code>ContextIdFactory</code>来实现此目的:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> contextId <span class="token operator">=</span> ContextIdFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jest
  <span class="token punctuation">.</span><span class="token function">spyOn</span><span class="token punctuation">(</span>ContextIdFactory<span class="token punctuation">,</span> <span class="token string">'getByRequest'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">mockImplementation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> contextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以使用这个contextId来在任何子请求中获取一个生成的注入容器子树。</p> <div class="language-ts extra-class"><pre class="language-ts"><code>catsService <span class="token operator">=</span> <span class="token keyword">await</span> moduleRef<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>CatsService<span class="token punctuation">,</span> contextId<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=nest" title="标签">#nest</a></div> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/nestJs/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">概述</div></a> <a href="/pages/7bfa8b/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">中间件</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/nestJs/" class="prev">概述</a></span> <span class="next"><a href="/pages/7bfa8b/">中间件</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/aiAgent/model/"><div>
            Agent多模态
            <!----></div></a> <span class="date">01-13</span></dt></dl><dl><dd>02</dd> <dt><a href="/aiAgent/bacis/"><div>
            Agent基础
            <!----></div></a> <span class="date">01-13</span></dt></dl><dl><dd>03</dd> <dt><a href="/aiAgent/design/"><div>
            Agent模式
            <!----></div></a> <span class="date">01-13</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1730129114@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wshuhua" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/my/m/music/playlist?id=7141103351" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2026
    <span>Wsh  | <a href="https://github.com/wshuhua" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b9210fed.js" defer></script><script src="/assets/js/2.dc8a2400.js" defer></script><script src="/assets/js/51.3c1116c5.js" defer></script>
  </body>
</html>
