<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Agent基础 | Wsh&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/images/logo.png">
    <meta name="description" content="经常偷懒，偶尔更新的">
    
    <link rel="preload" href="/assets/css/0.styles.bc63fb2f.css" as="style"><link rel="preload" href="/assets/js/app.e947a2e7.js" as="script"><link rel="preload" href="/assets/js/2.dc8a2400.js" as="script"><link rel="preload" href="/assets/js/23.8a720082.js" as="script"><link rel="prefetch" href="/assets/js/10.0b1da748.js"><link rel="prefetch" href="/assets/js/11.8e999e9c.js"><link rel="prefetch" href="/assets/js/12.d98e8047.js"><link rel="prefetch" href="/assets/js/13.a19f7b3e.js"><link rel="prefetch" href="/assets/js/14.bc46e720.js"><link rel="prefetch" href="/assets/js/15.77a7cb2e.js"><link rel="prefetch" href="/assets/js/16.45f3798f.js"><link rel="prefetch" href="/assets/js/17.65043558.js"><link rel="prefetch" href="/assets/js/18.60c02aca.js"><link rel="prefetch" href="/assets/js/19.f6f74a85.js"><link rel="prefetch" href="/assets/js/20.fb7a117c.js"><link rel="prefetch" href="/assets/js/21.bf9c4a2f.js"><link rel="prefetch" href="/assets/js/22.f61b5f3f.js"><link rel="prefetch" href="/assets/js/24.ccbdb665.js"><link rel="prefetch" href="/assets/js/25.efcad5ae.js"><link rel="prefetch" href="/assets/js/26.dfd6a6f6.js"><link rel="prefetch" href="/assets/js/27.0a7cd79f.js"><link rel="prefetch" href="/assets/js/28.00b295c6.js"><link rel="prefetch" href="/assets/js/29.34f094d2.js"><link rel="prefetch" href="/assets/js/3.23e0fc9b.js"><link rel="prefetch" href="/assets/js/30.9e4742ce.js"><link rel="prefetch" href="/assets/js/31.a1e478a3.js"><link rel="prefetch" href="/assets/js/32.9dbcab01.js"><link rel="prefetch" href="/assets/js/33.f33026f3.js"><link rel="prefetch" href="/assets/js/34.65d50d6f.js"><link rel="prefetch" href="/assets/js/35.fb16738c.js"><link rel="prefetch" href="/assets/js/36.c4a7ff97.js"><link rel="prefetch" href="/assets/js/37.7ec40316.js"><link rel="prefetch" href="/assets/js/38.7469dc6a.js"><link rel="prefetch" href="/assets/js/39.6f4ca190.js"><link rel="prefetch" href="/assets/js/4.c704e751.js"><link rel="prefetch" href="/assets/js/40.51e51c93.js"><link rel="prefetch" href="/assets/js/41.5900a31e.js"><link rel="prefetch" href="/assets/js/42.a252892c.js"><link rel="prefetch" href="/assets/js/43.b3f0edd6.js"><link rel="prefetch" href="/assets/js/44.958cf58c.js"><link rel="prefetch" href="/assets/js/45.4b3d0faa.js"><link rel="prefetch" href="/assets/js/46.b98ec317.js"><link rel="prefetch" href="/assets/js/47.4f709b5a.js"><link rel="prefetch" href="/assets/js/48.49f6f150.js"><link rel="prefetch" href="/assets/js/49.21c14213.js"><link rel="prefetch" href="/assets/js/5.2db75e05.js"><link rel="prefetch" href="/assets/js/50.e541e900.js"><link rel="prefetch" href="/assets/js/51.d67ff266.js"><link rel="prefetch" href="/assets/js/52.a1f4c220.js"><link rel="prefetch" href="/assets/js/53.307f45fa.js"><link rel="prefetch" href="/assets/js/54.2e5a3401.js"><link rel="prefetch" href="/assets/js/55.3eec9d65.js"><link rel="prefetch" href="/assets/js/56.2f46988a.js"><link rel="prefetch" href="/assets/js/57.c2dc6634.js"><link rel="prefetch" href="/assets/js/58.c363b0ba.js"><link rel="prefetch" href="/assets/js/59.21b28039.js"><link rel="prefetch" href="/assets/js/6.9073f8bb.js"><link rel="prefetch" href="/assets/js/60.369be21b.js"><link rel="prefetch" href="/assets/js/61.ba1c7c56.js"><link rel="prefetch" href="/assets/js/62.50eb3244.js"><link rel="prefetch" href="/assets/js/63.f6aef6a2.js"><link rel="prefetch" href="/assets/js/64.f0f8e740.js"><link rel="prefetch" href="/assets/js/65.a1b05e03.js"><link rel="prefetch" href="/assets/js/66.cbbd6786.js"><link rel="prefetch" href="/assets/js/67.fca809e1.js"><link rel="prefetch" href="/assets/js/68.83a7702e.js"><link rel="prefetch" href="/assets/js/69.ccd9e7f9.js"><link rel="prefetch" href="/assets/js/7.6922c449.js"><link rel="prefetch" href="/assets/js/70.6be8b1bf.js"><link rel="prefetch" href="/assets/js/71.4d664b96.js"><link rel="prefetch" href="/assets/js/72.e32651ee.js"><link rel="prefetch" href="/assets/js/73.bf55aa84.js"><link rel="prefetch" href="/assets/js/74.f33ef55f.js"><link rel="prefetch" href="/assets/js/75.82e1159c.js"><link rel="prefetch" href="/assets/js/76.e22ff448.js"><link rel="prefetch" href="/assets/js/77.556fc7e8.js"><link rel="prefetch" href="/assets/js/78.35d531d9.js"><link rel="prefetch" href="/assets/js/79.be7b54f4.js"><link rel="prefetch" href="/assets/js/8.922b3edf.js"><link rel="prefetch" href="/assets/js/80.297f19ce.js"><link rel="prefetch" href="/assets/js/81.30215707.js"><link rel="prefetch" href="/assets/js/82.00f77924.js"><link rel="prefetch" href="/assets/js/83.40e4eec1.js"><link rel="prefetch" href="/assets/js/84.bcf6db6c.js"><link rel="prefetch" href="/assets/js/85.e2b0e4cf.js"><link rel="prefetch" href="/assets/js/86.eb24944b.js"><link rel="prefetch" href="/assets/js/87.a6c9eb63.js"><link rel="prefetch" href="/assets/js/88.66d10613.js"><link rel="prefetch" href="/assets/js/9.c1b7ec7e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc63fb2f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu only-sidebarItem"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/1.gif" alt="Wsh's blog" class="logo"> <span class="site-name can-hide">Wsh's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AIGC" class="dropdown-title"><a href="/aiAgent/" class="link-title router-link-active">AIGC</a> <span class="title" style="display:none;">AIGC</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/aiAgent/bacis/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Agent基础</a></li><li class="dropdown-item"><!----> <a href="/aiAgent/design/" class="nav-link">Agent设计模式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="harmonyOS" class="dropdown-title"><a href="/harmonyOS/" class="link-title">harmonyOS</a> <span class="title" style="display:none;">harmonyOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/harmonyOS/base/" class="nav-link">基础知识</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/ArkUI/" class="nav-link">ArkUI</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/UIAbility/" class="nav-link">UIAbility</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/state/" class="nav-link">组件通信方式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">前端缓存</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">typescript</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/note/flutter/" class="nav-link">flutter</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/web3D/" class="nav-link">web3D😉</a></div><div class="nav-item"><a href="/pages/library/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/images/avatar.gif"> <div class="blogger-info"><h3>wsh</h3> <span>人未老，想养老</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="AIGC" class="dropdown-title"><a href="/aiAgent/" class="link-title router-link-active">AIGC</a> <span class="title" style="display:none;">AIGC</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/aiAgent/bacis/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Agent基础</a></li><li class="dropdown-item"><!----> <a href="/aiAgent/design/" class="nav-link">Agent设计模式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="harmonyOS" class="dropdown-title"><a href="/harmonyOS/" class="link-title">harmonyOS</a> <span class="title" style="display:none;">harmonyOS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/harmonyOS/base/" class="nav-link">基础知识</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/ArkUI/" class="nav-link">ArkUI</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/UIAbility/" class="nav-link">UIAbility</a></li><li class="dropdown-item"><!----> <a href="/harmonyOS/state/" class="nav-link">组件通信方式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">前端缓存</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">typescript</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">javascript</a></li><li class="dropdown-item"><!----> <a href="/note/flutter/" class="nav-link">flutter</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/web3D/" class="nav-link">web3D😉</a></div><div class="nav-item"><a href="/pages/library/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/aiAgent/bacis/" aria-current="page" class="active sidebar-link">Agent基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_01-什么是ai-agent-智能体" class="sidebar-link">01-什么是AI Agent（智能体）</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_02-ai-agent的主流设计模式有哪些" class="sidebar-link">02-AI Agent的主流设计模式有哪些</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_03-什么是ai-agent中的function-call" class="sidebar-link">03-什么是AI Agent中的function call？</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_04-什么是ai-agent中的mcp" class="sidebar-link">04-什么是AI Agent中的MCP</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_05-ai-agent中function-call-和mcp中的区别是什么" class="sidebar-link">05-AI Agent中function call 和MCP中的区别是什么？</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_06-ai-agent中的agent2agent-a2a" class="sidebar-link">06-AI Agent中的Agent2Agent(A2A)</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_07-ai-agent中的a2a和mcp的区别是什么" class="sidebar-link">07-AI Agent中的A2A和MCP的区别是什么？</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_08-ai-agent系统提示词有哪些作用" class="sidebar-link">08-AI Agent系统提示词有哪些作用</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_09-system-prompt-在ai-agent如何生效" class="sidebar-link">09-System Prompt 在AI Agent如何生效</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_10-ai-search和普通search有什么区别" class="sidebar-link">10-AI Search和普通Search有什么区别</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_11-什么是deepsearch" class="sidebar-link">11-什么是DeepSearch</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_12-ai-agent和ai-workflow的区别在哪里" class="sidebar-link">12-AI Agent和AI Workflow的区别在哪里</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_13-在ai-agent中-function-call如何把外部工具变成大模型可以理解的方式" class="sidebar-link">13 -在AI Agent中，function call如何把外部工具变成大模型可以理解的方式</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_14-在ai-agent中-大模型如何学习到function-calling能力" class="sidebar-link">14-在AI Agent中，大模型如何学习到Function Calling能力？</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_15-当前-ai-agent-有哪些局限性" class="sidebar-link">15- 当前 AI Agent 有哪些局限性</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_16-当前-ai-agent有哪些主流的评价指标" class="sidebar-link">16- 当前 AI Agent有哪些主流的评价指标</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_17-ai-agent如何具备长期记忆能力" class="sidebar-link">17-. AI Agent如何具备长期记忆能力？</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_18-ai-agent中的以及机制的原理与作用" class="sidebar-link">18- AI Agent中的以及机制的原理与作用</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_19-介绍一下ai-agent的上下文工程的原理" class="sidebar-link">19- 介绍一下AI Agent的上下文工程的原理</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_20-主流的ai-agent" class="sidebar-link">20 -主流的AI Agent</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_21-主流的ai-agent中包含哪些核心模块" class="sidebar-link">21- 主流的AI Agent中包含哪些核心模块</a></li><li class="sidebar-sub-header level2"><a href="/aiAgent/bacis/#_22-ai-agent中memory和rag有哪些区别" class="sidebar-link">22- AI Agent中Memory和RAG有哪些区别</a></li></ul></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/aiAgent/#aiAgent" data-v-0c557b5e>aiAgent</a></li></ul> <div class="info" data-v-0c557b5e><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2026-01-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Agent基础<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="_01-什么是ai-agent-智能体"><a href="#_01-什么是ai-agent-智能体" class="header-anchor">#</a> 01-什么是AI Agent（智能体）</h2> <p>Agent的核心思想是使用预压模型来选择要采取的一系列操作。在Agent中，语言模型被用作推理引擎来确认要采用哪些操作以及按照什么顺序。相对比传统机械或软件被动的给予输入-&gt;做出输出的模式，Agent由于更加强调自主的发现问题、确定目标、构想方案、选择方案、执行方案、检查更新的特性，因此可以被认为是一类拥有自主智能的实体,而被广泛称为智能体。</p> <p><strong>非智能体、智能体以及人类创作者的工作流呈现显著差异：</strong></p> <table><thead><tr><th>主体类型</th> <th>执行特征</th> <th>流程剖析</th></tr></thead> <tbody><tr><td>Non-Agent（非智能体）</td> <td>线性单次输出</td> <td>用户输入提示词→大模型直接生成终稿（无迭代过程）</td></tr> <tr><td>AI Agent（智能体</td> <td>多阶段认知闭环</td> <td>规划大纲→检索资料→生成初稿→自检修订→循环优化→输出终稿（模拟人类创作思维）</td></tr> <tr><td>人类创作者</td> <td>认知驱动型工作流</td> <td></td></tr></tbody></table> <p>AI Agent的核心是通过任务解构-执行-反思的认知闭环，实现对人类工作范式的数字孪生</p> <p>AI行业大牛吴恩达认为：AI Agent的终极演变方向是构建具备完整认知能力的数字主题。技术架构可以分为四个核心</p> <ul><li>反思：AI Agent 模拟人类自我修正行为，如:学生完成作业后的自我检查过程。突破单次推理局限，建立错误检测-反馈-修正的增强回路</li> <li>工具调用： AI Agent判断自身边界能力，选择合适的AI 工具来提供大模型的能力边界</li> <li>规划：AI Agent在解决复杂问题时，为达到目标制定合理的行为计划能力，从而对任务进行分解。</li> <li>多智能体协同：多个AI Agent的组合应用，</li></ul> <h2 id="_02-ai-agent的主流设计模式有哪些"><a href="#_02-ai-agent的主流设计模式有哪些" class="header-anchor">#</a> 02-AI Agent的主流设计模式有哪些</h2> <p>当前主流的AI Agent都是基于LLM大模型 + 一整套AIGC算法解决方案(Prompts工程、Function Call、MCP、AI工程策略、AI功能服务等)构建而成，同事蔚来还会持续扩展其内涵。</p> <p>基于上面额框架，接着再形成了5种主流的AI Agent设计模式:</p> <ol><li><strong>反射模式</strong>：这个模式的核心运作机制是构建自检-纠错迭代环，AI Agent会审查其工作及发现错误并迭代，直到生成最终输出结果。</li> <li><strong>工具使用模式</strong>：AI Agent允许LLM大模型通过使用外部工具获得更多信息，包括调用API，使用AI服务，查询矢量数据库、执行Python脚本等。这使得LLM大模型不仅仅依赖于其内部知识，还可以获得互联网世界的庞大实时数据流来扩展知识边界。</li> <li><strong>ReAct模式</strong>: ReAct模式结合了反射模式与工具使用模式，这使其成为当前AI Agent使用的最强大的模式之一。 AI Agent既可以自我思考，自我纠错，还可以使用工具与世界交互。</li> <li><strong>规划模式</strong>：在这种模式下，AI Agent根据任务的复杂程度,设计任务计划流程，对任务进行细分，再对细分子任务动用ReAct模式进行处理</li> <li><strong>多智能体模式</strong>：在这个模式下，AI Agent系统中包括多个子Agent，每个子Agent都分配有一个专用的角色和任务，同时每个子Agent还可以访问外部工具进行综合工作。最后，所有子Agent协同工作以提供最终结果，同时根据需要将细分任务委派给其他子Agent，形成一个复杂的”AI Agent协同社区“。</li></ol> <h2 id="_03-什么是ai-agent中的function-call"><a href="#_03-什么是ai-agent中的function-call" class="header-anchor">#</a> 03-什么是AI Agent中的function call？</h2> <p>在AI Agent中，Function Call(函数调用)本质上是智能体通过LLM大模型调用外部能力(API、AI服务、AI工具、数据库、搜索引擎等)并进行整合处理的闭环处理。</p> <p>买一个红色毛衣
流程：需求解析-&gt; 工具决策-&gt;结果整合</p> <p><strong>Function Call 与传统API调用的本质区别</strong></p> <table><thead><tr><th>维度</th> <th>传统API调用</th> <th>Agent Function Call</th></tr></thead> <tbody><tr><td>输入格式</td> <td>结构化参数</td> <td>自然语言指令</td></tr> <tr><td>调用方</td> <td>开发者硬编码触发</td> <td>Agent自主决策触发</td></tr> <tr><td>错误处理</td> <td>显示异常捕获</td> <td>反射机制自动重试、替换工具</td></tr> <tr><td>协议依赖</td> <td>固定通信协议(REST、gRPC)</td> <td>支持MCP等自适应协议</td></tr></tbody></table> <h2 id="_04-什么是ai-agent中的mcp"><a href="#_04-什么是ai-agent中的mcp" class="header-anchor">#</a> 04-什么是AI Agent中的MCP</h2> <p>MCP全称：Model Context Protocal，构建了AI大模型与外部应用程序间的上下文交互规范，这使得AI开发者能够以一致的规范将各种实时数据源、AI工具与外接功能连接到AIGC大模型中。</p> <p>MCP由三个核心组件构成：Host、Client和Server、</p> <p>Host:AI Agent作为Host，负责接受我们的提问与其中的AIGC大模型交互。Client：当AIGC大模型需要确定毛衣购买方案时，Host内置的MCP Client会被激活。这个Client负责与适当的MCP Server建立连接。Server：在这个例子中，毛衣购买方案MCP Server会被调用。它负责执行实际的毛衣购买方案确定操作，访问对应的电商API，并返回找到的毛衣购买方案。</p> <p>整个流程：我们的问题-&gt;AI Agent(Client) -&gt;AIGC模型 -&gt; 需要购买的毛衣信息 -&gt; MCP Client 连接 -&gt; 毛衣购买MCP Server -&gt; 执行操作 -&gt; 返回结果 -&gt; AIGC大模型生成回答 -&gt; 显示在AI Agent上</p> <h2 id="_05-ai-agent中function-call-和mcp中的区别是什么"><a href="#_05-ai-agent中function-call-和mcp中的区别是什么" class="header-anchor">#</a> 05-AI Agent中function call 和MCP中的区别是什么？</h2> <p>在AI Agent领域，MCP可以说是function call的更进一步延伸和封装</p> <p>function call解决了AIGC大模型与外部应用工具交互的问题，而MCP在此基础上对交互的整个流程进行规范化，从而解决海量数据、AIGC大模型、AI应用工具之间的“孤岛问题”</p> <h2 id="_06-ai-agent中的agent2agent-a2a"><a href="#_06-ai-agent中的agent2agent-a2a" class="header-anchor">#</a> 06-AI Agent中的Agent2Agent(A2A)</h2> <p>Agent2Agent(A2A)协议是驱动多智能体生态系统的核心通信框架，其本质是AI Agent之间的标准化协议，也是Agent之间的&quot;社会契约&quot;</p> <p>在没有A2A协议之前，不同的Agent A (ds) 与Agent B(GPT-4o) 输出格式各异，无法进行协同合作，形成了很多的AI Agent孤岛</p> <p>因此通过A2A协议，为异构AI Agent之间的互通与交互提供通用的语言：</p> <p><img src="/images/aiAgent/1.png" alt=""></p> <h2 id="_07-ai-agent中的a2a和mcp的区别是什么"><a href="#_07-ai-agent中的a2a和mcp的区别是什么" class="header-anchor">#</a> 07-AI Agent中的A2A和MCP的区别是什么？</h2> <p>MCP协议解决的是AI Agent和各种外部工具/资源之间的交互问题，可以看做是一个AI应用商店协议，主要关注单个AI Agent如何更好的使用外部工具。</p> <p>而A2A协议解决的是AI Agent 和AI Agent之间的交互问题，主要关注不同的AI Agent之间怎么协作的问题
总的来说，他们是互补的，共同构建AI Agent的生态</p> <h2 id="_08-ai-agent系统提示词有哪些作用"><a href="#_08-ai-agent系统提示词有哪些作用" class="header-anchor">#</a> 08-AI Agent系统提示词有哪些作用</h2> <p>系统提示词(sys prompt)是 AI Agent的核心控制中枢</p> <ul><li>作用一：角色定义与人格建模</li></ul> <div class="language- extra-class"><pre class="language-text"><code># 法律顾问Agent示例
&quot;&quot;&quot;
身份：环球律所高级合伙人（执业15年）
专长领域：跨境并购、知识产权诉讼
语言风格：严谨专业，引用法条需标注出处
&quot;&quot;&quot;

</code></pre></div><ul><li>作用二: 能力边界锁定</li></ul> <div class="language- extra-class"><pre class="language-text"><code># 工具调用白名单
&quot;&quot;&quot;
可用工具：
  - contract_review：合同审查（输入PDF→输出风险报告）
  - clause_search：条款库检索（关键词→相似判例）
禁用行为：
  - 生成法律效力承诺
  - 解释未生效草案
&quot;&quot;&quot;
</code></pre></div><ul><li>作用三：认识框架植入</li></ul> <table><thead><tr><th>任务类型</th> <th>预设思维链</th></tr></thead> <tbody><tr><td>合同审查</td> <td>主体校验→权责分析→违约条款评估</td></tr> <tr><td>法律咨询</td> <td>事实提取→法条匹配→解决方案生成</td></tr></tbody></table> <ul><li>作用四：动态上下文管理</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&quot;&quot;&quot;
记忆规则：
  - 保留核心实体（公司名/金额/时间节点）
  - 丢弃情绪化表述（用户抱怨等）
  - 持久化关键日期（合同截止日）
&quot;&quot;&quot;
</code></pre></div><h2 id="_09-system-prompt-在ai-agent如何生效"><a href="#_09-system-prompt-在ai-agent如何生效" class="header-anchor">#</a> 09-System Prompt 在AI Agent如何生效</h2> <p>在AI Agent中，定义了三种核心消息类型：System Prompt、Assistant Prompt和User Prompt,三折功能明确区分：</p> <ol><li>User Prompt: 代表用户的值机输入问题</li> <li>Assistant Prompt: 代表大模型生成的回复问题</li> <li>System Prompt: 用于设定大模型的角色、基础指令等核心配置</li></ol> <p>那么， System Prompt是如何在AI Agent中生效</p> <p>在AIAgent中，System Prompt主要是起到静默作用，通常被置于用户输入之前，与Assistant Prompt和User Prompt组合输入到大模型中</p> <p>System Prompt与User Prompt的关键区别在于其位置与优先级: System Prompt 固定设置在输入文本序列的开端。</p> <p>一个完整的多轮对话提示词通常按以下模式拼接：</p> <div class="language- extra-class"><pre class="language-text"><code>System Prompt -&gt; User Prompt -&gt; Assistant Prompt -&gt; User Prompt... -&gt; Assistant Prompt
</code></pre></div><p>在此结构中，Assisant Prompt的主要作用是向大模型展示历史对话记录，并明确标注哪些内容源于用户的输入。通过这种结构模式数据预训练和微调的大模型能够理解：这些并非即时用户输入，而是对话历史。这有利于大模型更好把握上下文信息，从而更准确回应后续问题。</p> <ol><li>将核心角色定义和规则置于System Prompt中</li> <li>用户交互内容放在User Prompt里</li></ol> <div class="language- extra-class"><pre class="language-text"><code>[
      {
        role: 'system',
        content: this.cachePrompt,
      },
      {
        role: 'user',
        content: query,
      },
];
</code></pre></div><h2 id="_10-ai-search和普通search有什么区别"><a href="#_10-ai-search和普通search有什么区别" class="header-anchor">#</a> 10-AI Search和普通Search有什么区别</h2> <ul><li>本质区别在于是否具备语义理解、动态决策和主动推动能力</li></ul> <table><thead><tr><th>维度</th> <th>传统搜索</th> <th>AI Search</th></tr></thead> <tbody><tr><td>技术基础</td> <td>关键词匹配 + 倒排索引</td> <td>LLM + 知识图谱 + 强化学习</td></tr> <tr><td>交互方式</td> <td>用户输入明确关键词-&gt;返回匹配结果</td> <td>自然语言提问 -&gt; 理解意图 -&gt; 动态推理答案</td></tr> <tr><td>输出形式</td> <td>链接列表(需用户二次筛选)</td> <td>结构化答案 + 多模态结果 + 溯源依据</td></tr> <tr><td>目的</td> <td>快速检索已有的信息</td> <td>解决问题(甚至执行动作)</td></tr></tbody></table> <ul><li>核心能力差异
<ul><li>语义理解vs 字符匹配
<ul><li>传统:匹配关键词出现频率</li> <li>AI-Search:理解上下文和隐含需求</li></ul></li> <li>静态检索vs动态推理
<ul><li>传统搜索：仅聚合现有内容</li> <li>AI-Search:智能体模式</li></ul></li></ul></li></ul> <h2 id="_11-什么是deepsearch"><a href="#_11-什么是deepsearch" class="header-anchor">#</a> 11-什么是DeepSearch</h2> <p>DeepSeach的核心理念是通过在搜索、阅读、推理三个环节不断循环往复、直到找到最优答案。搜索环节利用搜索引擎探索互联网，而阅读环境则专注于对特定网页进行详尽的分析。推理环节则负责评估当前的状态，并决定是应该将原始问题拆解为更小的子问题</p> <h2 id="_12-ai-agent和ai-workflow的区别在哪里"><a href="#_12-ai-agent和ai-workflow的区别在哪里" class="header-anchor">#</a> 12-AI Agent和AI Workflow的区别在哪里</h2> <p>AI Workflow的运行过程都是预定义设计好的，AI Agent是运行时进行自主决策。我们在判断一个系统到底是哪一类时，主要是看它能不能在运行过程中动态决策，而不是看system prompt等提示词有多长。</p> <table><thead><tr><th>维度</th> <th>AI Agent</th> <th>AI Workflow</th></tr></thead> <tbody><tr><td>本质</td> <td>具有自主决策能力的智能实体</td> <td>预设步骤的任务自动化流程</td></tr> <tr><td>类比</td> <td>有思考能力的员工</td> <td>工厂的流水线</td></tr> <tr><td>决策时间</td> <td>设计阶段</td> <td>运行阶段</td></tr> <tr><td>决策权</td> <td>自主决策</td> <td>按预设规则执行</td></tr> <tr><td>可复现性</td> <td>稳定可复现</td> <td>需要实时记录行动log</td></tr> <tr><td>运行成本</td> <td>可精准估算</td> <td>存在波动性</td></tr></tbody></table> <p>AI Agent是”思考者“，解决做什么(what)的问题，AI Workflow 则是执行者，解决怎么做How的问题</p> <h2 id="_13-在ai-agent中-function-call如何把外部工具变成大模型可以理解的方式"><a href="#_13-在ai-agent中-function-call如何把外部工具变成大模型可以理解的方式" class="header-anchor">#</a> 13 -在AI Agent中，function call如何把外部工具变成大模型可以理解的方式</h2> <p>将外部工具转化为大模型可理解方式的核心机制: 接口描述标准化与执行逻辑衔接</p> <p>实现LLM/AIGC大模型理解并调用外部工具、插件或APi的核心，在于建立一套标准化的接口描述机制，并构建一个可靠的执行桥梁。该过程包含两个关键环节：</p> <ol><li>接口描述标准化</li></ol> <ul><li>定义结构化描述：为每个工具设计一个符合特定调用格式(常用如JSON/XML Schema)的结构化接口定义。该Schema必须清晰包含以下要素：
<ul><li>唯一标识符</li> <li>功能说明书</li> <li>参数规格</li></ul></li></ul> <ol start="2"><li>执行逻辑衔接</li></ol> <ul><li>向大模型提供工具目录: 在每次模型交互时，将当前所有可用工具的标准化描述作为上下文信息，整合到提示词信息的特定部分传递给大模型</li> <li>解析模型调用指令：应用程序持续监听模型的输出响应。一旦检测到符合预定义格式(如特定JSON/XML结构)的函数调用指定，立即进行解析</li> <li>定位并执行目标工具：根据解析出的工具标识符，定位到对应的外部工具/插件/API实现</li> <li>参数映射与校验: 从调用指令的参数列表中提取参数值，执行必要的类型转换和有效性校验，最终调用实际工具的接口</li> <li>获取与处理执行结果：捕获工具执行后的结果</li> <li>结果反馈闭环：将工具执行的结果格式化为文本信息，再次输入给大模型。</li></ul> <p>本质概括：该机制的核心是为每个外部工具创建一份清晰易懂的”自然说明书“，使模型能够理解其功能。同事，建立一个“翻译与执行层“，负责将大模型依据说明书生成的操作指令（JSON/XML Call） 翻译并转化为对实际工具的具体调用动作，并将工具的操作结果报告翻译回大模型能够处理的信息</p> <h2 id="_14-在ai-agent中-大模型如何学习到function-calling能力"><a href="#_14-在ai-agent中-大模型如何学习到function-calling能力" class="header-anchor">#</a> 14-在AI Agent中，大模型如何学习到Function Calling能力？</h2> <p>Function Calling 能力不是LLM/AIGC大模型原生具备的，当前AI主流的方式是通过监督微调(SUpervised Fine-tuning, SFT)来实现LLM/AIGC大模型对Function Calling能力的学习。</p> <p>Function Calling 能力微调训练的核心思想：</p> <ol><li>获取识别意图：理解用户的请求是否需要借助外部工具/函数来完成，而不是直接生成文本回答。</li> <li>获取参数提取与格式化能力：如果需要调用函数，正确的从用户请求中抽取出所需的参数，并按照预先定义的格式(JSON/XML)生成函数调用的指令。</li></ol> <p>Function Calling的微调过程：</p> <ol><li><strong>数据集制作</strong>：一个用户请求，可以是包含调用函数的内容，也可以是不包含调用函数的内容。比如：给我写一首大气的诗.</li></ol> <ul><li>可用函数/工具描述：一个结构化的描述，告知大模型当前有哪些函数可用，每个函数的用途，所需参数以及类型和描述。这个描述本身通常就是文本，需要设计一个清晰的格式(JSON,XML)</li> <li>期望的输出：如果需要调用函数：一个特定格式的字符串，通常是包含函数名和提取出的参数的JSON、XML对象；如果不需要调用函数、大模型直接生成文本回答。</li> <li>数据集整体质量要求：</li> <li>数据多样性：需要足够多、覆盖各种场景的高质量数据</li> <li>函数描述的清晰度：函数描述的质量直接影响模型能否正确理解和使用函数</li> <li>负样本：需要包含足够多明确不需要调用Function的样本，防止模型”过渡触发“Function调用</li></ul> <p>Function 参数结构化格式例子：</p> <div class="language- extra-class"><pre class="language-text"><code>{
&quot;name&quot;: &quot;get_stock_change&quot;,
&quot;arguments&quot;: {
  &quot;stock_name&quot;: &quot;腾讯股票&quot;,
}
}
</code></pre></div><p>数据集格式</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;conversations&quot;: [
        {
            &quot;from&quot;: &quot;human&quot;,
            &quot;value&quot;: &quot;帮我查询一下今天股票的涨跌幅情况?&quot;
        },
        {
            &quot;from&quot;: &quot;gpt&quot;,
            &quot;value&quot;: &quot;当然，我可以帮忙，请问你对哪只股票感情兴趣?&quot;
        },
        {
            &quot;from&quot;: &quot;human&quot;,
            &quot;value&quot;: &quot;腾讯股票&quot;
        },
        {
            &quot;from&quot;: &quot;gpt&quot;,
            &quot;value&quot;: &quot;{\n\&quot;function\&quot;: \&quot;get_stock_change\&quot;,\n\&quot;arguments\&quot;: {\n\&quot;stock_name\&quot;: \&quot;腾讯股票\&quot;\n}\n}&quot;
        }
    ]
}
</code></pre></div><ol start="2"><li><strong>选择基础模型</strong>:选择一个具备强大指令遵循能力的预训练LLM/AIGC大模型</li> <li><strong>格式化训练</strong>：将每条数据样本组合成大模型可以理解的格式。通常是将数据集中的&quot;用户输入&quot;和”可用函数/工具描述“拼接起来作为模型输入，将期望的输出作为目标输出。需要使用特定的分割符或模板来区分不同部分。</li> <li>进行微调训练：使用标准的SFT方法(全参数微调或者训练LoRA)在特定数据集上进行微调训练。大模型的优化目标是最小化预测输出和期望输出之间的差异。大模型通过学习这些样本，学会根据用户输入和可用函数描述，决定是直接回答还是生成特定格式的函数调用JSON、XML</li></ol> <h2 id="_15-当前-ai-agent-有哪些局限性"><a href="#_15-当前-ai-agent-有哪些局限性" class="header-anchor">#</a> 15- 当前 AI Agent 有哪些局限性</h2> <ol><li>AI Agent的幻觉问题：AI Agent中的核心LLM/AIGC大模型可能会生成不准确的信息</li> <li>上下文长度与规划缺陷：LLM/AIGC大模型的上下文窗口有限，导致AI Agent难以处理长期有效任务和自我反思</li> <li>多模态处理能力不成熟：不管是B端还是C端场景，很多需求都是处理图像、文本、视频、音频等异构数据，但是多数AI Agent仍以文本这个单一模态为主</li> <li>行业适配困难：企业级场景要求零失误，但通常AI Agent容错率高，难以满足医疗、金融等高风险领域需求。垂直行业业务逻辑复杂，需深度绑定数据与流程。</li> <li>计算成本高： AI Agent运行推理会消耗大量计算资源。</li></ol> <h2 id="_16-当前-ai-agent有哪些主流的评价指标"><a href="#_16-当前-ai-agent有哪些主流的评价指标" class="header-anchor">#</a> 16- 当前 AI Agent有哪些主流的评价指标</h2> <ol><li>任务成功率：层级任务完成率、郭晨轨迹精确度、长周期策略稳定性等</li> <li>工具调用准确率</li> <li>推理质量</li> <li>用户满意度</li></ol> <h2 id="_17-ai-agent如何具备长期记忆能力"><a href="#_17-ai-agent如何具备长期记忆能力" class="header-anchor">#</a> 17-. AI Agent如何具备长期记忆能力？</h2> <p>要让AI Agent具备长期记忆能力，需要解决LLM/AIGC大模型固有的上下文窗口限制和无状态缺陷</p> <p>具备长期记忆的AI Agent需要采用 分层存储 + 智能检索 架构，核心是通过向量化、摘要压缩、混合数据库 打破上下文窗口限制</p> <ol><li>长期记忆的架构设计</li></ol> <ul><li>AI Agent的记忆需模拟人脑结构，分为三层协同工作：</li> <li>短期记忆：通过上下文窗口(如transfor的token限制)维持当前对话连贯性，但容量有限制(通常4k-128k token)</li> <li>中期记忆：将对话关键信息压缩为摘要或嵌入向量，存储于向量数据库，支持语义检索</li> <li>长期记忆：持久化存储用户画像、行为习惯等结构化数据，使用SQL/NoSQL数据库或者知识图谱实现跨会话记忆</li></ul> <ol start="2"><li>关键实现技术</li></ol> <ul><li>记忆生成与压缩</li> <li>摘要提炼
<ul><li>每次对话结束后，用专用LLM生成摘要</li></ul></li> <li>嵌入向量化
<ul><li>通过BERT或OpenAI Embedding将文本转为向量，便于高效检索</li></ul></li> <li>记忆检索与更新</li> <li>多模态检索：结合语义搜索(向量相似度) + 时间过滤(最近事件优先) + 规则筛选(如重要度评分)</li> <li>冲突消解：当新旧记忆矛盾时，由LLM裁决或设置衰减权重</li> <li>记忆集成至Agent
将检索结果动态注入Prompt</li></ul> <div class="language- extra-class"><pre class="language-text"><code>m.add(user_query, user_id='Alice)
related_memories = m.search('推荐电影', user_id='Alice') #检索相关记忆
prompt = f&quot;User's historical preferences: {related_memories}. Current query: {new_query}&quot;
response = llm.generate()
</code></pre></div><h2 id="_18-ai-agent中的以及机制的原理与作用"><a href="#_18-ai-agent中的以及机制的原理与作用" class="header-anchor">#</a> 18- AI Agent中的以及机制的原理与作用</h2> <ol><li>为什么需要记忆？ - 从金鱼脑说起</li></ol> <div class="language- extra-class"><pre class="language-text"><code>你：我叫小明，我喜欢打篮球。
AI：你好小明！打篮球是一项很棒的运动。
你：我最好的朋友叫小王。
AI：小王听起来是个不错的朋友。
你：那我和小王周末经常一起做什么？
</code></pre></div><p>这时，AI不会记忆之前的对话，就像是一条只有7秒记忆的金鱼。</p> <p>核心问题：标准的LLM是”无状态“的，每次对话，它都只基于你当前输入的提示词来生成回答，一旦对话结束，这些上下文信息就蒸发了</p> <p>而一个真正的AI Agent，是需要执行复杂的，多步骤任务的(比如帮你规划整个旅行行程，作为客服处理一个完整的客诉，作为游戏角色与你长期互动)。如果它没有记忆，每一步都像是从头开始。</p> <p>所以。记忆机制就是为了让AI Agent拥有持续学习、积累经验，并基于完整上下文进行决策的能力。</p> <ol start="2"><li>记忆机制的原理：它如何工作？</li></ol> <ul><li>记忆的类型(像大脑的不同功能区)</li></ul> <div class="language- extra-class"><pre class="language-text"><code> - 短期记忆：
  - 是什么：相当于Agent的工作台或者大脑当前活跃区域。它保存着当前任务直接相关的、最近的信息
  - 技术实现：通常就是对话上下文。当你与Agent聊天时，你之前说的N句话(比如最近10轮对话)会作为提示词的一部分，一起送到模型，让它知道刚才我们聊了什么
- 长期记忆
 - 是什么：相当于Agent的个人日记或知识库。它存储着需要被长期保留的重要信息，比如你的个人偏好，从过往任务重学到的经验，关于世界的事实
 - 技术实现：一个外部向量数据库。这是记忆系统的核心。
  - 步骤1：编码:当AI认为某段信息很重要，他会通过一个模型将这段时间转换为一串数字
  - 步骤2：存储：将这串数字和对应的原始文本一起存入数据库
  - 步骤3：检索：当需要用到记忆时，AI会将当前问题也转换为向量，然后在数据库里搜索语义上最相关的向量片段
</code></pre></div><ul><li>记忆的流动：一个完整的闭环一个配置了记忆机制的AI Agent，其工作流程是这样的：感知 -&gt; 思考 -&gt; 行动 -&gt; 记忆 的循环
<ul><li>感知： Agent接收到新的信息</li> <li>检索：Agent自动从长期记忆库中搜索相关的记忆</li> <li>思考：Agent将新的输入 + 检索到的长期记忆 + 当前的短期记忆组合成一个丰富的提示词，送给大语言模型进行推理</li> <li>行动：大语言模型基于完整的上下文，生成回答</li> <li>记忆：Agent决定是否将这次交互中有价值的信息存储到长期记忆中，以备将来使用。同时，这次对话本身进入了短期记忆的上下文窗口</li></ul></li></ul> <p>3.记忆机制的作用：它带来了什么</p> <ul><li>记忆机制从根本上提升了AI Agent的能力天花板，使其从”工具“向”伙伴“演进
<ul><li><ol><li>实现连续性与个性化</li></ol> <ul><li>作用：让 Agent能够记住用户的身份、偏好、习惯和历史互动。你不需要在每次对话中重复介绍自己</li></ul></li> <li>积累与学习能力
<ul><li>作用： Agent可以从过去的成功与失败中学习。它可以把解决过的问题和方法存入记忆，下次遇到类似情况时，直接调用，提高效率</li></ul></li> <li>维持状态与上下文
<ul><li>作用：在复杂的多步骤中，记忆机制帮助Agent维持任务的状态，知道我已经完成了哪几部，下一步该做什么</li></ul></li> <li>支持复杂推理与规划
<ul><li>作用：只有拥有丰富的背景知识，才能进行深度的、基于上下文的推理和长远规划</li></ul></li></ul></li></ul> <ol start="4"><li>一个生动的比喻：图书管理员</li></ol> <p>可以把AIAgent的记忆机制想象成一个超级图书馆管理员</p> <ul><li>大语言模型：是这位管理员本身的知识和口才</li> <li>短期记忆：是他手边正在翻阅的那几本书</li> <li>长期记忆：是整个庞大的图书馆藏书</li> <li>检索记忆：是管理员掌握的高效图书检索系统。当他需要回答时，他会先用自己的口才（LLM），结合手边的书(短期记忆)，同时用检索系统 从图书馆（长期记忆）找到最相关的书籍来佐证，最后给出一个完美的答案。</li></ul> <p>总结：
记忆机制是AI Agent的灵魂档案室，它将大语言模型一次性，孤立的智能，转变成了持续的，进化的，具备上下文意识的智能。</p> <h2 id="_19-介绍一下ai-agent的上下文工程的原理"><a href="#_19-介绍一下ai-agent的上下文工程的原理" class="header-anchor">#</a> 19- 介绍一下AI Agent的上下文工程的原理</h2> <ol><li>什么是上下文工程？
简单来说，上下文工程是指为AI Agent精心设计、组织和管理其所能接触到的信息，使其能够更准确、更连贯、更高效地完成任务的一整套方法，策略和技术。</li></ol> <p>可以想象成一个非常聪明但患有”短期失忆症“的助手准备一个完美的”工作备忘录“。这个备忘录里面包含：</p> <ul><li>它要做什么(任务指令)</li> <li>它之前做了什么(历史对话和行动)</li> <li>它知道什么(相关知识库)</li> <li>它能用什么(可调用的工具列表)</li> <li>它应该注意什么(行为准则和约束)</li></ul> <ol start="2"><li>为什么上下文如此重要？ - 原理的核心</li></ol> <p>大模型语言工作机制：它是一种基于上下文额自回归预测模型</p> <ol><li>无状态性：LLM本身是&quot;无状态&quot;的。每次调用之间互不相干。它根据这个文本预测下一个最可能得词/令牌，如此循环。它没有内置的记忆来记住上一次你和它说了什么。</li> <li>上下文窗口是唯一的”工作记忆区“：模型能够看到和处理的全部信息，就是当前这次请求所携带的上下文。这个上下文就是它的整个世界、全部的工作记忆。模型的所有推理、决策和回答，都完全基于所提供的这个上下文。</li></ol> <p>因此,上下文工程的根本原理就是：通过精心控制模型的”输入信息“，来引导和约束模型的”输出行为“，从而模拟出智能、连贯、有状态的代理行为。</p> <ol start="3"><li>上下文的关键组成部分</li></ol> <p>一个为AI Agent设计的高质量上下文，通常包含以下几个核心部分，这也是上下文工程需要精心构筑的模块</p> <ul><li>系统提示|角色设定
<ul><li>内容：定义Agent的人设，核心职责、目标和行为规范</li> <li>作用：在任务开始时为Agent设定一个稳定的”心智模型“，告诉它”你是谁“、你该做什么以及你该如何表现</li></ul></li> <li>任务指令与目标
<ul><li>内容：清晰、具体地描述当前需要完成的任务</li> <li>作用：为本次交互提供明确的方向</li></ul></li> <li>对话与行动历史
<ul><li>内容：记录用户与Agent之间多轮对话的完整记录，以及Agent之前调用工具/执行行动的内容和结果</li> <li>作用：提供连贯性。让Agent能够引用之前说话的话，理解用户的指代，并避免重新操作</li> <li>原理：这是模拟“记忆”和状态的关键。没有历史，每个问题对Agent来说都是全新的</li></ul></li> <li>外部知识与文档
<ul><li>内容：通过检索增强生成等技术，从向量数据库、知识库或网络中获取、与当前任务相关的信息</li> <li>作用：弥补LLM知识的时效性和专有性不足，为其决策提供事实依据。</li></ul></li> <li>工具与函数定义
<ul><li>内容：描述Agent可以调用的外部工具的列表，包括他们的名称、描述、参数格式等</li> <li>作用：扩展Agent的行动能力，使其不在局限于文本生成，而是可以执行具体操作</li> <li>原理：通过提供工具描述，引导模型在遇到特定情况时选择并结构化调用正确的工具</li></ul></li> <li>结构化输出要求
<ul><li>内容：要求模型以特定的格式输出其思考过程或最终答案</li> <li>作用：便于后端的程序解析模型的输出，实现自动化流程。这对于Agent的“思考-行动”循环至关重要</li></ul></li></ul> <ol start="4"><li>上下文工程的核心原理和策略</li></ol> <p>原理1： 分层与优先级
上下文窗口是有限的宝贵资源。必须高效利用</p> <ul><li>策略</li> <li>系统提示优先且稳定：系统提示通常放在最前面，并且在整个会话中尽量保持稳定，它是Agent的基石</li> <li>相关性筛选：不是所有的历史记录和外部知识都同样重要。使用检索器根据当前问题，动态地从海量信息中找出最相关的片段放入上下文。这是RAG的核心</li> <li>历史摘要/压缩：当对话很长时，将遥远的对话历史压缩陈一个简洁的摘要，而不是完整地保留所有的原始文本，以节省空间。</li></ul> <p>原理2：思维过程与推理框架
要让Agent完成复杂任务，需要引导它进行逐步推理</p> <ul><li>策略：
<ul><li>在上下文中提供思考模板：通过在系统提示中明确要求Agent按照思考-行动-观察的步骤来工作
<ul><li>思考：分析现状，决定下一步做什么</li> <li>行动：调用工具或生成回答</li> <li>观察：记录行动的结果</li> <li>示例（ReAct模式）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>思考：用户需要知道北京的天气来决定是否带伞。我知道当前日期，但不知道实时天气。我需要调用天气查询工具。
</code></pre></div></li></ul></li></ul> <p>行动：调用工具[get_weather(城市=&quot;北京&quot;)]
观察：工具返回结果：北京，晴，气温25°C。
思考：根据天气信息，北京是晴天，不需要带伞。我可以把这个信息告诉用户。
回答：北京今天是晴天，气温25°C，出门不需要带伞哦！
```
- 通过将这种结构化的思考过程也放入上下文中(通过是模型的输出中)，我们迫使模型进行更深入，更逻辑化的推理，而不仅仅是给出最终答案</p> <p>原理3：动态管理与状态维持
由于上下文窗口的限制与任务的长期性，上下文必须是动态变化的</p> <ul><li>策略：
<ul><li>滑动窗口：只保留最近N轮对话，丢弃最老的对话。简单但可能丢失关键长期信息</li> <li>智能摘要: 如上所述，由Agent或一个单独的流程定期对过去的交互进行总结，将摘要而非全文放入上下文。</li> <li>向量化长期记忆：将重要的用户信息、任务状态等存储在外部数据库。等需要时，再通过检索的方式将其拉回上下文。这实现了长期记忆与工作记忆的分离</li></ul></li></ul> <h2 id="_20-主流的ai-agent"><a href="#_20-主流的ai-agent" class="header-anchor">#</a> 20 -主流的AI Agent</h2> <table><thead><tr><th>框架名称</th> <th>执核心特点特征</th> <th>典型应用场景</th></tr></thead> <tbody><tr><td>LangChain</td> <td>模块化组件、生态丰富，链式编排工作流</td> <td>快速原型验证，高度定制的单Agent应用，如文档问答，客服自动化</td></tr> <tr><td>LangGraph</td> <td>基于图的工作流，强大的状态管理和循环控制</td> <td>复杂决策系统，多Agent协调，长周期任务</td></tr> <tr><td>CrewAI</td> <td>角色驱动，强调智能体检的结构化分工与写作</td> <td>内容创建，数据分析，商业策划等有明确分工的协作任务</td></tr> <tr><td>AutoGen</td> <td>对话驱动，通过多轮自然语言对话实现智能体协作</td> <td>研究探索，代码生成，需要创建新思维的场景</td></tr> <tr><td>Semantic Kernel</td> <td>企业级集成，强大的安全合规性，插件架构</td> <td>现有系统的智能化改造</td></tr> <tr><td>Dify</td> <td>低代码/零代码，可视化界面，快速构建和部署</td> <td>中小企业快速构建知识库问答，快速原型</td></tr> <tr><td>OpenAI Agents SDK</td> <td>轻量级，支持多模型，内置调式工具</td> <td>邮件优雅的多代理系统</td></tr></tbody></table> <h2 id="_21-主流的ai-agent中包含哪些核心模块"><a href="#_21-主流的ai-agent中包含哪些核心模块" class="header-anchor">#</a> 21- 主流的AI Agent中包含哪些核心模块</h2> <p>五大核心模块</p> <ol><li>规划模块：这是AI Agent的大脑，负责思考与决策</li></ol> <ul><li>任务分解：将负责的用户指令拆解成一系列可执行的子任务</li> <li>战略制定：规划完整任务的最佳路线和顺序，处理子任务之间的依赖关系</li> <li>反思与校准：在行动过程中或结束后，评估当前结果是否满足要求，并进行自我纠正。这是实现复杂任务的关键</li></ul> <ol start="2"><li>工具使用模块</li></ol> <ul><li>工具库：一个Agent可以调用的外部工具，API或函数的集合</li> <li>调用和执行：Agent 根据规划模块的决策，选择正确的工具，生成正确的参数，并执行调用</li> <li>结果处理：接收工具返回的结果，并将其标准化，传递给其他模块</li></ul> <ol start="3"><li>记忆模块
这是Agent的经验库，用户存储和检索信息，分为</li></ol> <ul><li>短期记忆：保留当前对话或任务链的上下文，确保对话的关联性</li> <li>长期记忆：通过向量数据库等技术，保存跨对话的长期知识、用户偏好、历史决策和结果，供未来任务参考。</li></ul> <ol start="4"><li>行动输出模块
这是Agent的最终表达。将内部决策转化为用户可感知的输出</li></ol> <ul><li>生成最终答案：在不需要调用工具或所有步骤完成后，生成自然语言回复</li> <li>生成结构化指令：当需要与环境交互时，生成工具调用的指令</li> <li>交付最终话结果：例如:返回一篇写完的文章，一段生成的代码，一个创建好的文件等</li></ul> <ol start="5"><li><p>串联模块的灵魂：感知与推理循环
单独拥有这些模块还不够，最关键的是让它们运转起来的核心控制流，即感知-思考行动循环，这通常由大模型的推理能力驱动</p></li> <li><p>感知：接收用户输入和环境的反馈</p></li> <li><p>思考</p></li></ol> <ul><li>规划模块结合记忆模块（历史上下文和知识）：决定下一步该做什么</li> <li>如果需要外部工具，工具使用模块被激活</li></ul> <ol start="3"><li>行动</li></ol> <ul><li>工具使用模块执行调用，并将结果协会记忆模块</li> <li>规划模块：根据结果进行反思，判断任务是否完成。如果未完成，回到第二步继续思考，如果完成，则通过行动输出模块给出最终结果</li></ul> <p>一个AI Agent的智能程度不仅取决于其核心大模型的能力，更取决于这些大模型设计的精巧程度与协作效率</p> <h2 id="_22-ai-agent中memory和rag有哪些区别"><a href="#_22-ai-agent中memory和rag有哪些区别" class="header-anchor">#</a> 22- AI Agent中Memory和RAG有哪些区别</h2> <p>AI Agent中Memory和RAG的本质区别</p> <table><thead><tr><th>维度</th> <th>Memory</th> <th>RAG</th></tr></thead> <tbody><tr><td>核心目的</td> <td>维持AI Agent的连续性、个性化和状态感知</td> <td>提供外部知识检索以增强生成能力</td></tr> <tr><td>存储内容</td> <td>会话历史、用户偏好、行动轨迹、内部状态</td> <td>结构化/非结构化文档、知识库、事实数据</td></tr> <tr><td>时间维度</td> <td>短期+长期记忆，具备时间序列特性</td> <td>静态知识，通常不随时间频繁变化</td></tr> <tr><td>更新频率</td> <td>实时、高频</td> <td>低频、批量更新</td></tr> <tr><td>数据结构</td> <td>图结构、序列结构、键值对、向量</td> <td>文档、向量、索引结构</td></tr></tbody></table> <p><strong>技术架构对比</strong></p> <ol><li>Memory机制</li></ol> <div class="language- extra-class"><pre class="language-text"><code>class AgentMemory:
  def _init_(self):
    // 短期记忆(对话上下文)
    self.short_term = []

    // 长期记忆(向量存储)
    self.long_term = VectorStore()

    // 经验记忆(强化学习)
    self.experience = ExperienceReplay()

    // 工作记忆(当前任务状态)
    self.working = TaskState()

# 关键组件
# - 对话历史管理
# - 状态跟踪器
# - 经验回放缓冲池
# - 记忆压缩/遗忘机制
# - 记忆检索和关联
</code></pre></div><ol start="2"><li>RAG系统</li></ol> <div class="language- extra-class"><pre class="language-text"><code># 典型RAG架构
class RAGSystem:
  def _init_(self):
    // 文档处理流水器
    self.doc_processor = DocumentProcessor()

    # 向量化模型
    self.embedder = EmbeddingModel()

    #向量数据库
    self.vector_db = VectorDatabase()

    #检索器
    self.retriever = Retriever()

    # 重排器
    self.reranker = Reranker()

# 关键组件
# - 文档分割和清晰
# - 向量索引构建
# - 相似性搜索算法
# - 上下文压缩和重组
# - 多跳检索能力
</code></pre></div><p><strong>功能差异详细分析</strong></p> <ul><li>Memory的核心功能
<ul><li>会话连续性<div class="language- extra-class"><pre class="language-text"><code>memory = [
  {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;我喜欢科幻电影&quot;},
  {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;推荐《星际穿越》&quot;},
  {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;还有类似的吗&quot;}, # 这里依赖记忆
]
</code></pre></div></li> <li>个性化适配
<ul><li>学习用户偏好</li> <li>适应交互风格</li> <li>记住用户特定信息</li></ul></li> <li>状态保持</li></ul> <div class="language- extra-class"><pre class="language-text"><code># 任务状态记忆
task_state = {
 &quot;current_step&quot;: 3,
 &quot;completed_steps&quot;: [&quot;收集需求&quot;, &quot;分析数据&quot;, &quot;生成大纲&quot;],
 &quot;next_action&quot;: &quot;编写执行计划&quot;,
 &quot;constraints&quot;: [&quot;预算限制: $100&quot;, &quot;时间限制：7天&quot;],
}
</code></pre></div><ul><li>经验学习</li> <li>从成功/失败中学习</li> <li>优化决策策略</li> <li>形成肌肉记忆</li></ul></li></ul> <p><strong>RAG的核心功能</strong></p> <ul><li>知识检索</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  #从知识库检索相关信息
  query = &quot;如何修复PostgreSQL连接错误？&quot;
  retrieved_docs = vector_db.similarity_search(
    query=query,
    k=5, # 返回5个最相关文档
    filter={&quot;source&quot;: &quot;官方文档&quot;}
  )
</code></pre></div><ul><li>事实增强
<ul><li>提供最新信息(避免LLM知识过时)</li> <li>提供详细数据(统计数字、技术细节等)</li> <li>提供权威来源引用</li></ul></li> <li>领域专业化<div class="language- extra-class"><pre class="language-text"><code>  # 专业领域知识搜索
  medical_rag = RAGSystem(
    docuements_medical_textbooks,
    embedding_model=&quot;med-bert&quot;,
    retrieval_strategy=&quot;hybrid_search&quot;
  )
</code></pre></div></li> <li>幻觉抑制
<ul><li>基于真实文档生成回答</li> <li>提供可验证的参考风险</li> <li>减少编造信息的风险</li></ul></li></ul> <p><strong>存储和检索方式对比</strong></p> <ul><li><p>Memory存储方式</p> <div class="language- extra-class"><pre class="language-text"><code># 1. 向量记忆
memory_vectors = embedder.encode([
  '用户偏好素食',
  '用户是软件工程师',
  '用户上次询问python问题',
])

# 2. 图记忆
memory_graph = {
  &quot;user&quot;: {&quot;likes&quot;: [&quot;scifi&quot;, &quot;coding&quot;], dislikes: [&quot;horror&quot;]},
  &quot;projects&quot;: {&quot;current&quot;: &quot;AI Agent&quot;, completed: [&quot;Web App&quot;]},
  &quot;conversations&quot;: {&quot;today&quot;: 5, &quot;total&quot;: 342},
}

# 3. 序列记忆
memory_timeline = [
  {&quot;timestamp&quot;: &quot;10:00&quot;, &quot;action&quot;: &quot;started_task&quot;, &quot;details&quot;: &quot;...&quot;},
  {&quot;timestamp&quot;: &quot;10:15&quot;, &quot;action&quot;: &quot;requested_data&quot;, &quot;details&quot;: &quot;...&quot;},
  {&quot;timestamp&quot;: &quot;10:30&quot;, &quot;action&quot;: &quot;completed_step&quot;, &quot;details&quot;: &quot;...&quot;}
]
</code></pre></div></li> <li><p>RAG存储方式</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code># 文档分块和向量化
documents = [
    &quot;PostgreSQL安装指南...&quot;,
    &quot;数据库优化技巧...&quot;,
    &quot;常见错误解决方案...&quot;
]

# 创建向量索引
vector_index = VectorIndex(
  documents=documents,
  chunk_size=500, #500字符一个块
  overlap=50, #块间重叠50字符
  embedding_model=&quot;text-embedding-ada-002&quot;
)

# 支持多种检索模式
retrieval_methods = {
  &quot;dense&quot;: vector_index.dense_retrieval,
  &quot;sparse&quot;: vector_index.bm25_retrieval,
  &quot;hybrid&quot;: vector_index.hybrid_retrieval,
  &quot;multi_vector&quot;: vector_index.multi_vector_retrieval
}
</code></pre></div></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=aiAgent" title="标签">#aiAgent</a></div> <!----></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/harmonyOS/state/"><div>
            组件通信方式
            <!----></div></a> <span class="date">01-08</span></dt></dl><dl><dd>02</dd> <dt><a href="/harmonyOS/UIAbility/"><div>
            UIAbility
            <!----></div></a> <span class="date">01-07</span></dt></dl><dl><dd>03</dd> <dt><a href="/harmonyOS/ArkUI/"><div>
            ArkUI
            <!----></div></a> <span class="date">01-06</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1730129114@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wshuhua" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/my/m/music/playlist?id=7141103351" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2026
    <span>Wsh  | <a href="https://github.com/wshuhua" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e947a2e7.js" defer></script><script src="/assets/js/2.dc8a2400.js" defer></script><script src="/assets/js/23.8a720082.js" defer></script>
  </body>
</html>
